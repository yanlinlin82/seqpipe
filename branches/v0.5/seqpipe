#!/usr/bin/perl -w
use strict;
use warnings;
use File::Basename;
use File::stat;
use Cwd 'abs_path';
use Fcntl qw(:flock);

############################################################
# Check perl multi-thread supporting

sub has_module
{
	my $name = shift;
	return 0 if not exists $INC{$name};
	return 0 if not defined $INC{$name};
	return 1;
}

BEGIN { eval 'use forks; use forks::shared; 1' or eval 'use threads; use threads::shared; 1' };
my $can_use_threads = 1;
if (not has_module('forks.pm') and not has_module('threads.pm')) {
	$can_use_threads = 0;
}

############################################################
# Constants

use constant UNIQ_ID => sprintf('%02d%02d%02d.%02d%02d.%d',
	(localtime)[5] % 100, (localtime)[4] + 1, (localtime)[3], (localtime)[2], (localtime)[1], $$);
use constant LOG_ROOT => './.seqpipe';  # All log files are saved in this directory.
use constant LOG_DIR => LOG_ROOT . '/' . UNIQ_ID;
use constant APP_ROOT => dirname abs_path $0;
use constant DEF_PIPE => APP_ROOT . '/default.pipe';

my $EMPTY_LINE      = '^\s*$';
my $COMMENT_LINE    = '^\s*#';
my $VERSION_LINE    = '^\s*#\[version="[^"]*".*\]\s*$';
my $ATTR_LINE       = '^\s*#\[\s*([\w\.]+)="[^"]*"(\s+([\w\.]+)="[^"]*")*\s*\]\s*$';
my $FUNC_LINE       = '^\s*function\s+([\w\.]+)\s*({|{{|)\s*$';
my $VAR_LINE        = '^\s*([\w\.]+)\s*=(.*)$';
my $BRACKET_LEFT    = '^\s*({|{{)\s*$';
my $BRACKET_RIGHT   = '^\s*(}|}})\s*$';
my $INC_LINE        = '^\s*SP_include\s+(.*)\s*$';
my $SP_SET          = '^\s*SP_set\s+([\w\.]+)\s*=(.*)$';
my $SP_RUN          = '^\s*SP_run\s+([\w\.]+)\s*(.*)$';
my $SP_IF_COND      = '^\s*SP_if\s+(|!)\s*\((.*)\)\s*$';
my $SP_IF_TEXT      = '^\s*SP_if\s+(.*)\s*$';
my $SP_ELSE_IF_COND = '^\s*SP_else_if\s+(|!)\s*\((.*)\)\s*$';
my $SP_ELSE_IF_TEXT = '^\s*SP_else_if\s+(.*)\s*$';
my $SP_ELSE         = '^\s*SP_else\s*$';
my $SP_FOR          = '^\s*(SP_for(_parallel|))\s+(\w+)=(.*)$';
my $SP_WHILE        = '^\s*SP_while\s+(|!)\s*\((.*)\)\s*$';

my @FILES_ATTR = ('require', 'input', 'output', 'output.temp', 'output.final');

############################################################
# Command line parsing results.

my $help_mode = 0;
my $list_mode = 0;
my $test_mode = 0;
my $show_mode = 0;
my $verbose = 0;
my $die_msg_tailing = '';

my $keep_temps = 0;
my $shell = '/bin/bash';

my $auto_load = 1;
my @files = ();
my @exec_cmds = ();

my $obsolete_warned = 0;
my $max_thread_number = 1;
my $thread_number :shared = 0;

my $procs_ref = {};  # All procedures are loaded at startup.
my $global_vars_ref = {}; # Global variables (defined outside procedures in .pipe files).
my %shell_env_vars :shared = (); # OS environment variables

my $run_counter :shared = 0;  # Count how many shell commands have run so far.

# Command line entered by user.
my $command_line = bash_line_encode(dirname(abs_path($0)) . '/seqpipe', @ARGV);

############################################################
# Time display helper functions

sub time_string
{
	my ($sec, $min, $hour, $mday, $mon, $year) = localtime shift;
	return sprintf('%04d-%02d-%02d %02d:%02d:%02d',
		$year + 1900, $mon + 1, $mday, $hour, $min, $sec);
}

sub time_elapse_string
{
	my ($start_time, $end_time) = @_;
	my $elapsed_time = $end_time - $start_time;
	my $time_elapse_text = '';
	if ($elapsed_time >= 86400) {
		$time_elapse_text .= int($elapsed_time / 86400) . 'd ';
		$elapsed_time %= 86400;
	}
	if ($time_elapse_text or $elapsed_time >= 3600) {
		$time_elapse_text .= int($elapsed_time / 3600) . 'h ';
		$elapsed_time %= 3600;
	}
	if ($time_elapse_text or $elapsed_time >= 60) {
		$time_elapse_text .= int($elapsed_time / 60) . 'm ';
		$elapsed_time %= 60;
	}
	if ($time_elapse_text eq '' or $elapsed_time > 0) {
		$time_elapse_text .= $elapsed_time . 's ';
	}
	$time_elapse_text =~ s/\s$//g;
	return $time_elapse_text;
}

############################################################
# Log out functions

sub log_print
{
	if ($test_mode) {
		print @_;
	} else {
		flock LOG_FILE, LOCK_EX;
		print LOG_FILE @_;
		flock LOG_FILE, LOCK_UN;
	}
}

sub log_printf
{
	if ($test_mode) {
		printf @_;
	} else {
		flock LOG_FILE, LOCK_EX;
		printf LOG_FILE @_;
		flock LOG_FILE, LOCK_UN;
	}
}

############################################################
# Handling signal of Ctrl+C.

$SIG{'INT'} = sub {
	my $now = time_string time;
	log_print "(0) Aborts at $now\n";
};

############################################################
# Run ID allocation

sub get_new_run_id
{
	lock($run_counter);
	$run_counter++;
	return $run_counter;
}

############################################################
# Bash line parsing

sub bash_line_encode
{
	my @argv = @_;
	foreach my $arg (@argv) {
		$arg =~ s/\'/\'\\\'\'/g;
		if ($arg =~ /[\s|><]/) {
			if ($arg =~ /^(\w+)=(.*)$/) {
				$arg = "$1='$2'";
			} else {
				$arg = "'" . $arg . "'";
			}
		} elsif ($arg =~ /^(\w+)=$/) {
			$arg = "$1=\'\'";
		}
	}
	return join(' ', @argv);
};

sub split_bash_and_comment
{
	my ($line) = @_;

	# Split to bash command and tailing comment.
	return undef if $line !~ /^(("(\\.|[^"])*"|'[^']*'|[^\s#'"][^\s'"]*|\\.|\s+)*)(#.*|)$/;
	my $bash = $1;
	my $comment = $4;

	return ($bash, $comment);
}

sub bash_line_decode
{
	my ($cmd) = @_;

	my ($bash, $comment) = split_bash_and_comment($cmd);
	die 'Bad bash line!' if not defined $bash;
	$cmd = $bash;

	# Split bash command line to @argv.
	my @argv = ();
	while ($cmd =~ /(("(\\.|[^"])*"|'[^']*'|[^\s#][^\s'"]*|\\.)+)/g) {
		push @argv, $1;
	}

	# Process quot strings.
	foreach my $arg (@argv) {
		my $result = '';
		while ($arg =~ /("((\\.|[^"])*)"|'([^']*)'|([^\s'"]+))/g) {
			my $part = '';
			if (defined $2) {
				$part = $2;
				$part =~ s/\\(.)/$1/g;
			} elsif (defined $4) {
				$part = $4;
			} elsif (defined $5) {
				$part = $5;
			}
			$result .= $part;
		}
		$arg = $result;
	}
	return @argv;
}

############################################################

sub add_dep
{
	my ($name, $dep, $deps_ref) = @_;
	$deps_ref->{$name} = {} if not exists $deps_ref->{$name};
	$deps_ref->{$name}{$dep} = 1;
}

sub has_dep
{
	my ($name, $dep, $deps_ref, $indent) = @_;
	$indent = '' if not defined $indent;

	if ($name ne $dep and exists $deps_ref->{$name}) {
		return 1 if exists $deps_ref->{$name}{$dep};
		foreach my $sub (keys %{$deps_ref->{$name}}) {
			next if $sub eq $name;
			return 1 if has_dep($sub, $dep, $deps_ref, $indent . '  ');
		}
	}
	return 0;
}

############################################################

sub get_vars
{
	my ($args_ref, $proc_vars_ref, $gvars_ref) = @_;

	my %vars = ();
	foreach my $name (keys %{$args_ref}) {
		$vars{$name} = $args_ref->{$name};
	}
	foreach my $name (keys %{$proc_vars_ref}) {
		$vars{$name} = $proc_vars_ref->{$name} if not exists $vars{$name};
	}
	foreach my $name (keys %{$gvars_ref}) {
		$vars{$name} = $gvars_ref->{$name} if not exists $vars{$name};
	}
	return %vars;
}

sub get_vars_dep
{
	my %vars = @_;

	my %deps = ();
	foreach my $name (keys %vars) {
		while ($vars{$name} =~ /\${(\w+)}/g) {
			next if $name eq $1;           # Ignore self-dependency
			next if not exists $vars{$1};  # Ignore undefined variable
			die "ERROR: Cyclic-dependency between variables '$name' and '$1' detected!\n" if has_dep($1, $name, \%deps);
			$deps{$name} = {} if not exists $deps{$name};
			$deps{$name}{$1} = 1;
		}
	}
	return %deps;
}

sub sort_vars
{
	my ($vars_ref, $deps_ref) = @_;

	my %vars = %{$vars_ref};
	my @vars = ();
	search_again: while (%vars) {
		my $name = '';
		foreach (keys %vars) {
			next if exists $deps_ref->{$_};
			$name = $_;
			unshift @vars, $name;
			delete $vars{$name};
			delete $deps_ref->{$name};
			foreach my $dep (keys %{$deps_ref}) {
				my $sub_ref = $deps_ref->{$dep};
				delete $sub_ref->{$name} if exists $sub_ref->{$name};
				delete $deps_ref->{$dep} if not %{$sub_ref};
			}
			goto search_again;
		}
		last if $name eq '';
	}
	return @vars;
}

sub chk_vars_info
{
	my ($opt_vars_ref, $req_vars_ref, $args_ref, $proc_vars_ref, $gvars_ref, @texts) = @_;

	while (@texts) {
		my $text = shift @texts;
		while ($text =~ /\${(\w+)}/g) {
			next if exists $opt_vars_ref->{$1} or exists $req_vars_ref->{$1};
			if (exists $args_ref->{$1}) {
				push @texts, $opt_vars_ref->{$1} = $args_ref->{$1};
			} elsif (exists $proc_vars_ref->{$1}) {
				push @texts, $opt_vars_ref->{$1} = $proc_vars_ref->{$1};
			} elsif (exists $gvars_ref->{$1}) {
				push @texts, $opt_vars_ref->{$1} = $gvars_ref->{$1};
			} else {
				$req_vars_ref->{$1} = '';
			}
		}
	}
}

sub eval_text
{
	my ($text, $args_ref, $proc_vars_ref, $gvars_ref) = @_;

	my ($bash, $comment) = split_bash_and_comment($text);
	return '' if not defined $bash;
	$text = $bash;

	$text =~ s/^\s+//g;  # Remove leading white-spaces.
	$text =~ s/\s+$//g;  # Remove tailing white-spaces.
	$text =~ s/^"(.*?)"$/$1/;  # Remove quot marks.

	my %opt_vars = ();
	my %req_vars = ();
	chk_vars_info(\%opt_vars, \%req_vars, $args_ref, $proc_vars_ref, $gvars_ref, $text);

	my %vars = ();
	foreach my $name (keys %opt_vars) {
		$vars{$name} = $opt_vars{$name};
	}
	foreach my $name (keys %req_vars) {
		$vars{$name} = "\${$name}";
	}

	my %deps = get_vars_dep %vars;
	my @order = sort_vars(\%vars, \%deps);

	foreach my $name (@order) {
		if ($text =~ /\${$name}/) {
			$text =~ s/\${$name}/$vars{$name}/g;
		}
	}
	return $text;
}

############################################################

sub chk_vars_dep
{
	my ($args_ref, $proc_vars_ref, $gvars_ref) = @_;

	my %deps = ();
	foreach my $name (keys %{$args_ref}, keys %{$proc_vars_ref}, keys %{$gvars_ref}) {
		my $value = '';
		if (exists $args_ref->{$name}) {
			$value = $args_ref->{$name};
		} elsif (exists $proc_vars_ref->{$name}) {
			$value = $proc_vars_ref->{$name};
		} elsif (exists $gvars_ref->{$name}) {
			$value = $gvars_ref->{$name};
		}
		
		while ($value =~ /\${(\w+)}/g) {
			my $dep = $1;
			die "ERROR: Cyclic-dependency between variables '$name' and '$dep' detected!\n" if has_dep($dep, $name, \%deps);
			add_dep($name, $dep, \%deps);
		}
	}
}

sub chk_files_dep
{
	my ($requires_of_ref, $inputs_of_ref) = @_;

	my %deps = ();
	foreach my $file (keys %{$requires_of_ref}) {
		foreach my $dep (keys %{$requires_of_ref->{$file}}) {
			die "ERROR: Cyclic-dependency between files '$file' and '$dep' detected!\n" if has_dep($dep, $file, \%deps);
			add_dep($file, $dep, \%deps);
		}
	}
	foreach my $file (keys %{$inputs_of_ref}) {
		foreach my $dep (keys %{$inputs_of_ref->{$file}}) {
			die "ERROR: Cyclic-dependency between files '$file' and '$dep' detected!\n" if has_dep($dep, $file, \%deps);
			add_dep($file, $dep, \%deps);
		}
	}
}

############################################################

sub merge_vars_info
{
	my ($opt_vars_ref, $req_vars_ref, $sub_info_ref) = @_;

	foreach my $name (keys %{$sub_info_ref->{opt_vars}}) {
		next if exists $opt_vars_ref->{$name} or exists $req_vars_ref->{$name};
		$opt_vars_ref->{$name} = $sub_info_ref->{opt_vars}{$name};
	}
	foreach my $name (keys %{$sub_info_ref->{req_vars}}) {
		next if exists $opt_vars_ref->{$name} or exists $req_vars_ref->{$name};
		$req_vars_ref->{$name} = $sub_info_ref->{req_vars}{$name};
	}
}

sub add_dep_info
{
	my ($requires_of_ref, $inputs_of_ref, $outputs_ref, $saves_ref, $temps_ref,
		$args_ref, $proc_vars_ref, $gvars_ref,
		$cmd_requires_ref, $cmd_inputs_ref, $cmd_outputs_ref, $cmd_saves_ref, $cmd_temps_ref) = @_;

	foreach my $output (keys %{$cmd_outputs_ref}) {
		my $output_result = eval_text($output, $args_ref, $proc_vars_ref, $gvars_ref);
		next if $output_result eq '';
		next if exists $outputs_ref->{$output_result};
		$outputs_ref->{$output_result} = $output;
	}

	foreach my $save (keys %{$cmd_saves_ref}) {
		my $save_result = eval_text($save, $args_ref, $proc_vars_ref, $gvars_ref);
		next if $save_result eq '';
		next if exists $saves_ref->{$save_result};
		$saves_ref->{$save_result} = $save;
	}

	foreach my $temp (keys %{$cmd_temps_ref}) {
		my $temp_result = eval_text($temp, $args_ref, $proc_vars_ref, $gvars_ref);
		next if $temp_result eq '';
		next if exists $temps_ref->{$temp_result};
		$temps_ref->{$temp_result} = $temp;
	}

	foreach my $output (keys %{$cmd_outputs_ref}) {
		my $output_result = eval_text($output, $args_ref, $proc_vars_ref, $gvars_ref);

		foreach my $require (keys %{$cmd_requires_ref}) {
			my $require_result = eval_text($require, $args_ref, $proc_vars_ref, $gvars_ref);
			next if $require_result eq '';
			$requires_of_ref->{$output_result} = {} if not exists $requires_of_ref->{$output_result};
			$requires_of_ref->{$output_result}{$require_result} = $require;
		}

		foreach my $input (keys %{$cmd_inputs_ref}) {
			my $input_result = eval_text($input, $args_ref, $proc_vars_ref, $gvars_ref);
			next if $input_result eq '';
			$inputs_of_ref->{$output_result} = {} if not exists $inputs_of_ref->{$output_result};
			$inputs_of_ref->{$output_result}{$input_result} = $input;
		}
	}
}

sub trace_dep
{
	my ($output_ref, $info_ref, $is_require) = @_;

	foreach my $output (keys %{$output_ref}) {
		if (exists $info_ref->{requires_of}{$output}) {
			my %items = ();
			foreach my $file (keys %{$info_ref->{requires_of}{$output}}) {
				if (not exists $info_ref->{requires}{$file}) {
					$info_ref->{requires}{$file} = $info_ref->{requires_of}{$output}{$file};
					$items{$file} = '';
				}
			}
			if (%items) {
				trace_dep(\%items, $info_ref, 1);
			}
		}
		if (exists $info_ref->{inputs_of}{$output}) {
			my %items = ();
			foreach my $file (keys %{$info_ref->{inputs_of}{$output}}) {
				if (defined $is_require and $is_require) {
					if (not exists $info_ref->{requires}{$file}) {
						$info_ref->{requires}{$file} = $info_ref->{inputs_of}{$output}{$file};
						$items{$file} = '';
					}
				} else {
					if (not exists $info_ref->{inputs}{$file}) {
						$info_ref->{inputs}{$file} = $info_ref->{inputs_of}{$output}{$file};
						$items{$file} = '';
					}
				}
			}
			if (%items) {
				trace_dep(\%items, $info_ref, $is_require);
			}
		}
	}
}

sub transform_vars
{
	my ($vars_ref, $options_ref) = @_;
	foreach my $name (keys %{$vars_ref}) {
		$vars_ref->{$name} = eval_text($vars_ref->{$name}, $options_ref, {}, {});
	}
}

sub transform_files
{
	my ($files_ref, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref) = @_;
	my %results = ();
	foreach my $file (keys %{$files_ref}) {
		my $expand_one_level = eval_text($file, $options_ref, {}, {});
		my $expand_all_level = eval_text($expand_one_level, $args_ref, $proc_vars_ref, $gvars_ref);
		$results{$expand_all_level} = $expand_one_level;
	}
	%{$files_ref} = %results;
}

sub transform_deps
{
	my ($deps_ref, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref) = @_;
	my %results = ();
	foreach my $file (keys %{$deps_ref}) {
		my $file_expand_one_level = eval_text($file, $options_ref, {}, {});
		my $file_expand_all_level = eval_text($file_expand_one_level, $args_ref, $proc_vars_ref, $gvars_ref);
		foreach my $dep (keys %{$deps_ref->{$file}}) {
			my $dep_expand_one_level = eval_text($dep, $options_ref, {}, {});
			my $dep_expand_all_level = eval_text($dep_expand_one_level, $args_ref, $proc_vars_ref, $gvars_ref);
			$results{$file_expand_all_level} = {} if not exists $results{$file_expand_all_level};
			$results{$file_expand_all_level}{$dep_expand_all_level} = $dep_expand_one_level;
		}
	}
	%{$deps_ref} = %results;
}

sub transform_info
{
	my ($info_ref, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref) = @_;

	transform_vars($info_ref->{opt_vars}, $options_ref);
	transform_vars($info_ref->{req_vars}, $options_ref);

	transform_files($info_ref->{requires}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);
	transform_files($info_ref->{inputs}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);
	transform_files($info_ref->{outputs}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);
	transform_files($info_ref->{saves}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);
	transform_files($info_ref->{temps}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);

	transform_deps($info_ref->{requires_of}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);
	transform_deps($info_ref->{inputs_of}, $options_ref, $args_ref, $proc_vars_ref, $gvars_ref);
}

sub chk_files
{
	my ($info_ref, $indent, $run_id) = @_;

	foreach my $require (keys %{$info_ref->{requires}}) {
		if (not -e $require) {
			log_print "$indent($run_id) ERROR: Required file '$require' does not exist!\n";
			return -1;
		}
	}

	foreach my $input (keys %{$info_ref->{inputs}}) {
		if (not -e $input) {
			log_print "$indent($run_id) ERROR: Input file '$input' does not exist!\n";
			return -1;
		}
	}
	
	if (exists $info_ref->{outputs} and %{$info_ref->{outputs}}) {
		foreach my $output (keys %{$info_ref->{outputs}}) {
			if (exists $info_ref->{requires}{$output} or exists $info_ref->{inputs}{$output}) {
				log_print "$indent($run_id) ERROR: Output file '$output' has also been defined as require or input!\n";
				return -1;
			}
			if (-e $output) {
				foreach my $input (keys %{$info_ref->{inputs}}) {
					if ((stat($input))->mtime > (stat($output))->mtime) {
						return 0;
					}
				}
			} else {
				my $output_dir = dirname $output;
				system 'mkdir', '-p', $output_dir unless -d $output_dir;
				return 0;
			}
		}
		return 1;
	} else {
		# Force to run pipeline if no any output file defined.
		return 0;
	}
}

sub append_file
{
	my $file = shift;
	if (open FILE, '>>', $file) {
		print FILE @_;
		close FILE;
	}
}

sub try_guess_name
{
	my ($cmd) = @_;
	my @argv = bash_line_decode($cmd);
	my $name = '';
	while (@argv) {
		$name = basename shift @argv;
		$name =~ s/\W//g;
		last if $name;
	}
	if ($name eq '') {
		$name = 'shell';
	} else {
		while (@argv) {
			my $arg = shift @argv;
			last if $arg !~ /^\w+$/;
			$name .= "_$arg";
		}
	}
	return $name;
}

sub get_env_cmds
{
	my @env_cmds = ();
	{
		lock(%shell_env_vars);
		foreach my $name (keys %shell_env_vars) {
			push @env_cmds, "export $name=$shell_env_vars{$name}";
		}
	}
	return @env_cmds;
}

sub run_checker
{
	my ($cmd, $cmd_result, $run_id, $negative, $indent) = @_;
	
	append_file LOG_DIR . "/$run_id.check.cmd", $cmd_result, "\n";

	if (not open SHELL, '|-', $shell) {
		return undef;
	}
	print SHELL $cmd_result;
	close SHELL;
	
	if ($? & 0xFF) {
		return undef;
	}
	my $yes = (($? >> 8) == 0) ^ ($negative ne '');
	if (not $test_mode) {
		log_print "$indent($run_id) $cmd returns '" . ($yes ? 'yes' : 'no') . "'\n";
	}
	return $yes;
}

sub run_shell
{
	my ($command, $procedure_type, $cmd_name, $run_id, $indent) = @_;

	if ($test_mode) {
		print "$command\n";
		return 0;
	}

	my $name = $cmd_name;
	$name = try_guess_name($command) if not defined $name or $name eq '';
	my $err = '2>>' . LOG_DIR . "/$run_id.$name.err";
	my $out = '>>' . LOG_DIR . "/$run_id.$name.log";
	append_file LOG_DIR . "/$run_id.$name.cmd", $command, "\n";

	my $start_time = time;
	log_print "$indent($run_id) starts at " . time_string($start_time) . "\n";
	
	if (not open SHELL, '|-', $shell) {
		log_print "$indent($run_id) starts failed! (error: $!)\n";
		return undef;
	}
	print SHELL join("\n", '(', get_env_cmds(), $command, ')'), " $err $out";
	close SHELL;
	if ($? & 0xFF) {
		log_printf "$indent($run_id) aborted by signal %d (%s coredump)\n",
			($? & 0x7F), ($? & 0x80) ? 'with' : 'without';
		return undef;
	}
	my $ret = ($? >> 8);
	my $end_time = time;
	log_printf "$indent($run_id) ends at %s (elapsed: %s)\n",
		time_string($end_time), time_elapse_string($start_time, $end_time);
	log_print "$indent($run_id) returns $ret\n" if $ret != 0;
	return $ret;
}

sub eval_text_in_shell
{
	my ($text, $indent, $args_ref, $proc_vars_ref, $gvars_ref) = @_;

	my $result = eval_text($text, $args_ref, $proc_vars_ref, $gvars_ref);
	while (1) {
		# Following patterns require shell to eval
		last if $result =~ /\${\w+}/;
		last if $result =~ /\$\(\(.*\)\)/;
		last if $result =~ /{[0-9]+\.\.[0-9]+}/;
		last if $result =~ /{\S\.\.\S}/;
		last if $result =~ /{.*,.*}/;
		last if $result =~ /\$\(.*\)/;
		last if $result =~ /\*/;
		last if $result =~ /\?/;
		return $result;
	}
	my $cmd = "echo $result";
	if (open SHELL, '-|', "echo $cmd|$shell") {
		$result = join('', <SHELL>);
		chomp $result;
		close SHELL;
		if (not $test_mode) {
			my $run_id = get_new_run_id;
			log_print "$indent($run_id) [eval] $text\n";
		}
	}
	return $result;
}

############################################################
# Scripts loading

sub file_pos
{
	my ($fp) = @_;
	return "$fp->{file} line $fp->{line_no}";
}

sub read_one_line
{
	my ($fp) = @_;
	$fp->{line} = readline($fp->{handle});
	if (defined $fp->{line}) {
		chomp $fp->{line};
		++$fp->{line_no};
		while ($fp->{line} =~ /\s\\\s*$/) {
			my $line = readline($fp->{handle});
			if (not defined $fp->{line}) {
				undef $fp->{line};
				last;
			}
			chomp $line;
			++$fp->{line_no};
			$fp->{line} =~ s/\\\s*$//g;
			$fp->{line} .= "\n" . $line;
		}
	}
	return defined $fp->{line};
}

sub load_global_var
{
	my ($fp, $module, $allow_overwrite) = @_;
	die "ERROR: Parse global variable definition failed at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /$VAR_LINE/;
	my $name = $1;
	my ($value, $comment) = split_bash_and_comment($2);
	die "ERROR: Bad declaration format of global variable '$name' at " . file_pos($fp) . "\n$die_msg_tailing" unless defined $value;
	$value =~ s/^\s+//g;  # Remove leading white-spaces.
	$value =~ s/\s+$//g;  # Remove tailing white-spaces.
	$value =~ s/^"(.*?)"$/$1/;  # Remove quot marks.
	die "ERROR: Redeclaration of global variable '$name' at " . file_pos($fp) . "\n$die_msg_tailing"
		if not $allow_overwrite and exists $global_vars_ref->{$module}{$name};
	$global_vars_ref->{$module}{$name} = $value;
	chk_vars_dep({}, {}, {}, $global_vars_ref->{$module});
}

sub load_module_conf
{
	my ($conf_file, $module, $allow_overwrite) = @_;
	print "Load config: $conf_file\n" if $verbose;
	open my $handle, '<', $conf_file or die "ERROR: Can not open file '$conf_file'!\n$die_msg_tailing";
	my $fp = { handle => $handle, file => $conf_file, line_no => 0, line => '' };
	my $line_no = 0;
	while (read_one_line($fp)) {
		if ($fp->{line} =~ /$VAR_LINE/s) {
			load_global_var($fp, $module, $allow_overwrite);
		} elsif ($fp->{line} !~ /$EMPTY_LINE/s and $fp->{line} !~ /$COMMENT_LINE/s) {
			die "ERROR: Invalid syntax of configure file at " . file_pos($fp)
				. "\n  Only global variable definition could be included in configure file!\n$die_msg_tailing";
		}
	}
	close $handle;
}

sub parse_cmd_attr
{
	my ($fp, $cmd_ref) = @_;
	while ($fp->{line} =~ /([\w\.]+)="(.*?)"/g) {
		my $attr_name = $1;
		my $value = $2;
		if ($attr_name eq 'name') {
			die "ERROR: Duplicated attribute for command name at " . file_pos($fp) . "\n$die_msg_tailing" if defined $cmd_ref->{name};
			my $name = $2;
			die "ERROR: Invalid name '$name' at " . file_pos($fp) . "\n$die_msg_tailing" unless $name =~ /[\w\.]+/;
			$cmd_ref->{name} = $name;
		}
		my $valid = 0;
		foreach my $name (@FILES_ATTR) {
			if ($attr_name eq $name) {
				foreach (@FILES_ATTR) {
					if (exists $cmd_ref->{$_}{$value}) {
						die "ERROR: Duplicated attribute for $name file '$value'!\n$die_msg_tailing";
					}
				}
				$cmd_ref->{$name}{$value} = 1;
				$valid = 1;
			}
		}
		die "ERROR: Unknown procedure attribute '$attr_name' at " . file_pos($fp) . "\n$die_msg_tailing" unless $valid;
	}
}

sub load_sp_set
{
	my ($fp, $cmd_ref) = @_;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /$SP_SET/s;
	$cmd_ref->{var_name} = $1;
	($cmd_ref->{value}, $cmd_ref->{comment}) = split_bash_and_comment($2);
}

sub load_sp_run
{
	my ($fp, $cmd_ref) = @_;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /$SP_RUN/s;
	$cmd_ref->{proc_name} = $1;
	my @argv = bash_line_decode($2);
	foreach my $arg (@argv) {
		if ($arg eq '...') {
			$cmd_ref->{dots} = 1;
		} elsif ($arg =~ /$VAR_LINE/s) {
			push @{$cmd_ref->{options}}, { name => $1, value => $2 };
		} else {
			die "ERROR: Invalid option '$arg' for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing";
		}
	}
}

sub load_sp_if
{
	my ($fp, $cmd_ref) = @_;
	if ($fp->{line} =~ /$SP_IF_COND/s) {
		$cmd_ref->{negative} = $1;
		$cmd_ref->{condition} = $2;
	} elsif ($fp->{line} =~ /$SP_IF_TEXT/s) {
		$cmd_ref->{text} = $1;
	} else {
		die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing";
	}
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp) and $fp->{line} =~ /$BRACKET_LEFT/s;
	my $bracket = $1;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
	$cmd_ref->{block} = load_block($fp, $bracket);
	while ($fp->{line} =~ /^\s*SP_else_if\s/s) {
		my $else_ref = {};
		if ($fp->{line} =~ /$SP_ELSE_IF_COND/s) {
			$else_ref->{negative} = $1;
			$else_ref->{condition} = $2;
		} elsif ($fp->{line} =~ /$SP_ELSE_IF_TEXT/s) {
			$else_ref->{text} = $1;
		} else {
			die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing";
		}
		die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp) and $fp->{line} =~ /$BRACKET_LEFT/s;
		my $bracket = $1;
		die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
		$else_ref->{block} = load_block($fp, $bracket);
		push @{$cmd_ref->{else_if}}, $else_ref;
	}
	if ($fp->{line} =~ /$SP_ELSE/s) {
		die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp) and $fp->{line} =~ /$BRACKET_LEFT/s;
		my $bracket = $1;
		die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
		$cmd_ref->{else} = load_block($fp, $bracket);
	}
}

sub load_sp_for
{
	my ($fp, $cmd_ref) = @_;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /$SP_FOR/s;
	$cmd_ref->{var_name} = $3;
	$cmd_ref->{value} = $4;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp) and $fp->{line} =~ /$BRACKET_LEFT/s;
	my $bracket = $1;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
	$cmd_ref->{block} = load_block($fp, $bracket);
}

sub load_sp_while
{
	my ($fp, $cmd_ref) = @_;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /$SP_WHILE/s;
	$cmd_ref->{negative} = $1;
	$cmd_ref->{condition} = $2;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp) and $fp->{line} =~ /$BRACKET_LEFT/;
	my $bracket = $1;
	die "ERROR: Invalid syntax for $cmd_ref->{primitive} at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
	$cmd_ref->{block} = load_block($fp, $bracket);
}

sub load_primitive
{
	my ($fp, $cmd_ref) = @_;
	if ($fp->{line} =~ /^\s*(SP_set)\s/) {
		$cmd_ref->{primitive} = $1;
		load_sp_set($fp, $cmd_ref);
		read_one_line($fp);
	} elsif ($fp->{line} =~ /^\s*(SP_run)\s/) {
		$cmd_ref->{primitive} = $1;
		load_sp_run($fp, $cmd_ref);
		read_one_line($fp);
	} elsif ($fp->{line} =~ /^\s*(SP_if)\s+(.*)/) {
		$cmd_ref->{primitive} = $1;
		load_sp_if($fp, $cmd_ref);
	} elsif ($fp->{line} =~ /^\s*(SP_for(_parallel|))\s+/) {
		$cmd_ref->{primitive} = $2;
		load_sp_for($fp, $cmd_ref);
	} elsif ($fp->{line} =~ /^\s*(SP_while)\s/) {
		$cmd_ref->{primitive} = $1;
		load_sp_while($fp, $cmd_ref);
	} else {
		$fp->{line} =~ /^\s*([\w\.]+)\s/;
		die "ERROR: Unknown primitive '$1' at " . file_pos($fp) . "\n$die_msg_tailing";
	}
}

sub load_cmd
{
	my ($fp) = @_;
	my $cmd_ref = { file => $fp->{file}, line_no => $fp->{line_no} };
	while (defined $fp->{line}) {
		if ($fp->{line} =~ /$ATTR_LINE/) {
			parse_cmd_attr($fp, $cmd_ref);
		} elsif ($fp->{line} !~ /$COMMENT_LINE/ and $fp->{line} !~ /$EMPTY_LINE/) {
			last;
		}
		die 'Error: Invalid syntax for command at' . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
	}
	if (defined $fp->{line}) {
		if ($fp->{line} =~ /$BRACKET_LEFT/) {
			my $sub_bracket = $1;
			die "ERROR: Invalid syntax for block at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
			$cmd_ref->{block} = load_block($fp, $sub_bracket);
		} elsif ($fp->{line} =~ /^\s*SP_/) {
			load_primitive($fp, $cmd_ref);
		} else {
			$cmd_ref->{command} = $fp->{line};
			read_one_line($fp);
		}
	}
	return $cmd_ref;
}

sub load_block
{
	my ($fp, $bracket) = @_;
	my $block_ref = { file => $fp->{file}, line_no => $fp->{line_no}, parallel => ($bracket eq '{{' ? 1 : 0) };
	while (defined $fp->{line} and $fp->{line} !~ /$BRACKET_RIGHT/) {
		if ($fp->{line} =~ /$EMPTY_LINE/ or ($fp->{line} !~ /$ATTR_LINE/ and $fp->{line} =~ /$COMMENT_LINE/)) {
			read_one_line($fp);
			next;
		} else {
			push @{$block_ref->{commands}}, load_cmd($fp);
		}
	}
	if ($bracket eq '{') {
		die "ERROR: '}' expected for block at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /^\s*}\s*$/;
	} elsif ($bracket eq '{{') {
		die "ERROR: '}}' expected for block at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /^\s*}}\s*$/;
	}
	read_one_line($fp);
	return $block_ref;
}

sub load_proc
{
	my ($fp, $proc_name, $bracket) = @_;
	my $line_no = $fp->{line_no};
	if (exists $procs_ref->{$proc_name}) {
		die "ERROR: Duplicated procedure '$proc_name' at " . file_pos($fp)
			. "\n  Previous definition of '$proc_name' was at $procs_ref->{$proc_name}{file} line $procs_ref->{$proc_name}{line_no}"
			. "\n$die_msg_tailing";
	}
	die "ERROR: Invalid syntax for procedure at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
	if ($bracket eq '') {
		die "ERROR: '{' or '{{' expected at " . file_pos($fp) . "\n$die_msg_tailing" unless $fp->{line} =~ /$BRACKET_LEFT/;
		$bracket = $1;
		die "ERROR: Invalid syntax for procedure at " . file_pos($fp) . "\n$die_msg_tailing" unless read_one_line($fp);
	}
	$procs_ref->{$proc_name} = load_block($fp, $bracket);
	$procs_ref->{$proc_name}{name} = $proc_name;
	$procs_ref->{$proc_name}{file} = $fp->{file};
	$procs_ref->{$proc_name}{line_no} = $line_no;
}

sub init_envs
{
	my ($file) = @_;
	if (not exists $global_vars_ref->{''}) {
		$global_vars_ref->{''} = { _SEQPIPE => 'seqpipe', _SEQPIPE_ROOT => APP_ROOT };
	}
	%{$global_vars_ref->{$file}} = %{$global_vars_ref->{''}};
}

sub load_module
{
	my ($file) = @_;
	init_envs $file;
	printf "Load module: $file\n" if $verbose;
	open my $handle, '<', $file or die "ERROR: Can not open file '$file'!\n$die_msg_tailing";
	my $fp = { handle => $handle, file => $file, line_no => 0, line => '' };
	my $met_proc = 0;
	read_one_line($fp);
	while (defined $fp->{line}) {
		if ($fp->{line} =~ /$EMPTY_LINE/ or $fp->{line} =~ /$COMMENT_LINE/) {
			if ($fp->{line} =~ /$ATTR_LINE/ and $fp->{line} !~ /$VERSION_LINE/) {
				print "WARNING: Procedure attributes will be ignored at " . file_pos($fp) . "\n" if not $obsolete_warned;
				$obsolete_warned = 1;
			}
			read_one_line($fp);
		} elsif ($fp->{line} =~ /$INC_LINE/) {
			if ($met_proc) {
				print "WARNING: SP_include should be defined before procedures at " . file_pos($fp) . "\n" if not $obsolete_warned;
				$obsolete_warned = 1;
			}
			load_module_conf(dirname($file) . '/' . $1, $file, 0);
			read_one_line($fp);
		} elsif ($fp->{line} =~ /$VAR_LINE/) {
			if ($met_proc) {
				print "WARNING: Global variables should be defined before procedures at " . file_pos($fp) . "\n" if not $obsolete_warned;
				$obsolete_warned = 1;
			}
			load_global_var($fp, $file, 0);
			read_one_line($fp);
		} elsif ($fp->{line} =~ /$FUNC_LINE/) {
			$met_proc = 1;
			load_proc($fp, $1, $2);
		} else {
			die "ERROR: Invalid syntax at " . file_pos($fp) . "\n$die_msg_tailing";
		}
	}
	close $fp->{handle};
	# Load configure file to overwrite the default values of global variables
	load_module_conf("$file.conf", $file, 1) if -e "$file.conf";
}

############################################################
# Script displaying

sub show_sp_set
{
	my ($cmd_ref, $indent, $args_ref) = @_;
	# SP_set will be ignored if the options is given from command line
	if (not exists $args_ref->{$cmd_ref->{var_name}}) {
		print $indent, "SP_set $cmd_ref->{var_name}=$cmd_ref->{value}";
		print $cmd_ref->{comment} if $verbose;
		print "\n";
	}
}

sub show_sp_run
{
	my ($cmd_ref, $indent, $args_ref) = @_;
	print $indent, "SP_run $cmd_ref->{proc_name}";
	foreach my $option_ref (@{$cmd_ref->{options}}) {
		print " $option_ref->{name}=" . bash_line_encode($option_ref->{value});
	}
	print " ..." if exists $cmd_ref->{dots};
	print "\n";
}

sub show_sp_if
{
	my ($cmd_ref, $indent, $args_ref) = @_;
	print $indent, "SP_if ";
	print '!' if exists $cmd_ref->{negative};
	print "($cmd_ref->{condition})\n" if exists $cmd_ref->{condition};
	print "$cmd_ref->{text}\n" if exists $cmd_ref->{text};
	show_block($cmd_ref->{block}, $indent, $args_ref);
	foreach my $else_ref (@{$cmd_ref->{else_if}}) {
		print $indent, "SP_else_if ";
		print "!" if exists $else_ref->{negative};
		print "($else_ref->{condition})\n" if exists $else_ref->{condition};
		print "$else_ref->{text}\n" if exists $else_ref->{text};
		show_block($else_ref->{block}, $indent, $args_ref);
	}
	if (exists $cmd_ref->{else}) {
		print $indent, "SP_else\n";
		show_block($cmd_ref->{else}, $indent, $args_ref);
	}
}

sub show_sp_for
{
	my ($cmd_ref, $indent, $args_ref) = @_;
	print "$indent$cmd_ref->{primitive} $cmd_ref->{var_name}=$cmd_ref->{value}";
	show_block($cmd_ref->{block}, $indent, $args_ref);
}

sub show_sp_while
{
	my ($cmd_ref, $indent, $args_ref) = @_;
	print "$indent$cmd_ref->{primitive} ";
	print '!' if exists $cmd_ref->{negative};
	print "($cmd_ref->{condition})";
	show_block($cmd_ref->{block}, $indent, $args_ref);
}

sub show_primitive
{
	my ($cmd_ref, $indent, $args_ref) = @_;
	if ($cmd_ref->{primitive} eq 'SP_set') {
		show_sp_set $cmd_ref, $indent, $args_ref;
	} elsif ($cmd_ref->{primitive} eq 'SP_run') {
		show_sp_run $cmd_ref, $indent, $args_ref;
	} elsif ($cmd_ref->{primitive} eq 'SP_if') {
		show_sp_if $cmd_ref, $indent, $args_ref;
	} elsif ($cmd_ref->{primitive} eq 'SP_for' or $cmd_ref->{primitive} eq 'SP_for_parallel') {
		show_sp_for $cmd_ref, $indent, $args_ref;
	} elsif ($cmd_ref->{primitive} eq 'SP_while') {
		show_sp_while $cmd_ref, $indent, $args_ref;
	} else {
		die "ERROR: Unknown primitive '$cmd_ref->{primitive}'!";
	}
}

sub show_cmd
{
	my ($cmd_ref, $indent, $args_ref, $cmd_index) = @_;
	my $need_new_line = 0;
	if ($cmd_index > 0) {
		if ($verbose and (exists $cmd_ref->{name} or exists $cmd_ref->{require}
				or exists $cmd_ref->{input} or exists $cmd_ref->{output}
				or exists $cmd_ref->{'output.temp'} or exists $cmd_ref->{'output.final'})) {
			$need_new_line = 1;
		}
		if (exists $cmd_ref->{command}) {
			$need_new_line = 1;
		}
		if (exists $cmd_ref->{primitive} and $cmd_ref->{primitive} ne 'SP_set') {
			$need_new_line = 1;
		}
		if (exists $cmd_ref->{block}) {
			$need_new_line = 1;
		}
	}
	print "\n" if $need_new_line;
	if ($verbose) {
		print "$indent#[name=\"$cmd_ref->{name}\"\n" if $cmd_ref->{name};
		foreach my $key ('require', 'input', 'output', 'output.temp', 'output.final') {
			print "$indent#[$key=\"$_\"]\n" foreach (keys %{$cmd_ref->{$key}});
		}
	}
	if ($cmd_ref->{primitive}) {
		show_primitive $cmd_ref, $indent, $args_ref;
	} elsif ($cmd_ref->{block}) {
		show_block($cmd_ref->{block}, $indent, $args_ref);
	} else {
		my @lines = split(/\n/, $cmd_ref->{command});
		foreach my $line (@lines) {
			$line =~ s/^\s+//;
		}
		print $indent . join("\\\n$indent\t", @lines) . "\n";
	}
}

sub show_block
{
	my ($block_ref, $indent, $args_ref) = @_;
	print "$indent", ($block_ref->{parallel} ? '{{' : '{'), "\n";
	my $index = 0;
	foreach my $cmd_ref (@{$block_ref->{commands}}) {
		show_cmd $cmd_ref, "$indent\t", $args_ref, $index;
		++$index;
	}
	print $indent, ($block_ref->{parallel} ? '}}' : '}'), "\n";
}

sub show_proc
{
	my ($proc_name, $args_ref) = @_;
	print "function $proc_name\n" if $proc_name;
	show_block $procs_ref->{$proc_name}, '', $args_ref;
}

sub list_proc
{
	my ($pattern) = @_;
	if (%{$procs_ref}) {
		print "\nCurrent available procedures";
		print " (search for '$pattern')" if $pattern;
		print ":\n";
		foreach my $name (sort keys %{$procs_ref}) {
			next if $name =~ /^_/;
			print "   $name\n" if $name =~ /$pattern/;
		}
		print "\n";
	} else {
		print "\nNo any available procedures!\n\n";
	}
}

############################################################
# Check variables and dependencies

sub merge_info
{
	my ($info_ref, $cmd_info_ref, $cmd_ref) = @_;

	foreach my $type ('req_vars', 'opt_vars', 'dyn_vars') {
		while (my ($name, $value) = each (%{$cmd_info_ref->{$type}})) {
			$info_ref->{$type}{$name} = $value;
		}
	}
	foreach my $cmd_type (@FILES_ATTR) {
		while (my ($file, $def) = each (%{$cmd_info_ref->{$cmd_type}})) {
			if ($cmd_type eq 'require' or $cmd_type eq 'input') {
				$info_ref->{$cmd_type}{$file} = $def;
				if (exists $info_ref->{require}{$file} and exists $info_ref->{input}{$file}) {
					delete $info_ref->{require}{$file};
				}
			} else {
				my $found = 0;
				foreach my $proc_type ('require', 'input') {
					$found = 1 if exists $info_ref->{$proc_type}{$file};
				}
				print "WARNING: Previous input file may be overwrited as output at " . file_pos($cmd_ref) . "\n$die_msg_tailing" if $found;
				$info_ref->{$cmd_type}{$file} = $def;
			}
		}
	}
}

sub show_pair
{
	my ($a, $b) = @_;
	if (length($a) > 30) {
		printf "   %s\n   %-30s  %s\n", $a, '', $b;
	} else {
		printf "   %-30s  %s\n", $a, $b;
	}
}

sub show_info_files
{
	my ($msg, $files_ref) = @_;
	print "$msg\n";
	foreach my $file (sort keys %{$files_ref}) {
		show_pair($file, 'Definition: ' . $files_ref->{$file});
	}
	print "\n";
}

sub show_info
{
	my ($proc_name, $info_ref) = @_;
	if (exists $info_ref->{req_vars} or exists $info_ref->{dyn_vars} or ($help_mode == 2 and exists $info_ref->{opt_vars})) {
		print "Variables for " . ($proc_name ? "procedure '$proc_name'" : "inline commands") . ":\n";
		if (exists $info_ref->{req_vars}) {
			foreach my $var_name (sort keys %{$info_ref->{req_vars}}) {
				show_pair($var_name, 'Required');
			}
			print "\n";
		}
		if (exists $info_ref->{dyn_vars}) {
			foreach my $var_name (sort keys %{$info_ref->{dyn_vars}}) {
				show_pair($var_name, 'Runtime: ' . $info_ref->{dyn_vars}{$var_name});
			}
			print "\n";
		}
		if ($help_mode == 2 and exists $info_ref->{opt_vars}) {
			foreach my $var_name (sort keys %{$info_ref->{opt_vars}}) {
				show_pair($var_name, 'Default: ' . $info_ref->{opt_vars}{$var_name});
			}
			print "\n";
		}
	}
	if (exists $info_ref->{require} and %{$info_ref->{require}}) {
		show_info_files('Require file(s):', $info_ref->{require});
	}
	if (exists $info_ref->{input} and %{$info_ref->{input}}) {
		show_info_files('Input file(s):', $info_ref->{input});
	}
	if ($help_mode > 1) {
		if (exists $info_ref->{output} and %{$info_ref->{output}}) {
			show_info_files('Intermediate output file(s) (will not be removed):', $info_ref->{output});
		}
		if (exists $info_ref->{'output.temp'} and %{$info_ref->{'output.temp'}}) {
			show_info_files('Intermediate temporary file(s) (will be removed unless using "-k" option):', $info_ref->{'output.temp'});
		}
	}
	if (exists $info_ref->{'output.final'} and %{$info_ref->{'output.final'}}) {
		show_info_files(($help_mode > 1 ? 'Final output file(s):' : 'Output file(s):'), $info_ref->{'output.final'});
	}
	if ($help_mode < 2 and (
			(exists $info_ref->{opt_vars} and %{$info_ref->{opt_vars}}) or
			(exists $info_ref->{output} and %{$info_ref->{output}}) or
			(exists $info_ref->{'output.temp'} and %{$info_ref->{'output.temp'}}))) {
		print "NOTE: Use '-H' option to see more details\n\n";
	}
}

sub expand_text
{
	my @res = ();
	foreach my $text (@_) {
		if ($text =~ /{([0-9]+)..([0-9]+)}/) {
			my $start = $1;
			my $end = $2;
			if ($start <= $end) {
				for (my $i = $start; $i <= $end; ++$i) {
					push @res, $i;
				}
			} else {
				for (my $i = $start; $i >= $end; --$i) {
					push @res, $i;
				}
			}
		} elsif ($text =~ /{([A-Z])..([A-Z])}/) {
			my $start = $1;
			my $end = $2;
			if ($start <= $end) {
				for (my $i = $start; $i <= $end; ++$i) {
					push @res, $i;
				}
			} else {
				for (my $i = $start; $i >= $end; --$i) {
					push @res, $i;
				}
			}
		} elsif ($text =~ /{([a-z])..([a-z])}/) {
			my $start = $1;
			my $end = $2;
			if ($start <= $end) {
				for (my $i = $start; $i <= $end; ++$i) {
					push @res, $i;
				}
			} else {
				for (my $i = $start; $i >= $end; --$i) {
					push @res, $i;
				}
			}
		} elsif ($text =~ /{([^{},]+)((,[^{},])+)}/) {
			my $text_1 = $1;
			my $text_2 = $2;
		}
	}
	return @res;
}

sub is_unresolved
{
	my ($text) = @_;
	# TODO: ignore those in string.
	return 1 if $text =~ /{[0-9]\.\.[0-9]}/;
	return 1 if $text =~ /{[A-Z]\.\.[A-Z]}/;
	return 1 if $text =~ /{[a-z]\.\.[a-z]}/;
	return 1 if $text =~ /\$\(\(.+\)\)/;
	return 1 if $text =~ /\$\(.*\)/;
	return 1 if $text =~ /\*/;
	return 1 if $text =~ /\?/;
	return 0;
}

sub check_text
{
	my ($text, $args_ref, $vars_ref, $gvars_ref, $info_ref) = @_;
	my $flag = 1;
	while ($flag) {
		$flag = 0;
		# TODO: keep those ${XXX} in single quote marks not replaced.
		while ($text =~ /\${(\w+)}/g) {
			my $name = $1;
			if (exists $info_ref->{dyn_vars}{$name}) {
				next;
			}
			my $value;
			if (exists $args_ref->{$name}) {
				$value = $args_ref->{$name};
			} elsif (exists $vars_ref->{$name}) {
				$value = $vars_ref->{$name};
			} elsif (exists $gvars_ref->{$name}) {
				$value = $gvars_ref->{$name};
			} else {
				$info_ref->{req_vars}{$name} = '' unless exists $info_ref->{req_vars}{$name} or $info_ref->{dyn_vars}{$name};
				next;
			}
			$info_ref->{opt_vars}{$name} = $value unless exists $info_ref->{opt_vars}{$name};
			$text =~ s/\${$name}/$value/g;
			$flag = 1;
		}
	}
	return $text;
}

sub check_sp_set
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = {};
	my $name = $cmd_ref->{var_name};
	if (not exists $args_ref->{$name}) {
		my $text = $cmd_ref->{value};
		my $value = check_text($text, $args_ref, $vars_ref,
			$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
		if (is_unresolved($value)) {
			$info_ref->{dyn_vars}{$name} = $value;
			$vars_ref->{$name} = $text;
		} elsif (not exists $vars_ref->{$name}) {
			$info_ref->{opt_vars}{$name} = $text;
			$vars_ref->{$name} = $text;
		} else {
			die "ERROR: Variable '$name' has been changed again at " . file_pos($cmd_ref) . "\n$die_msg_tailing";
		}
	}
	return $info_ref;
}

sub check_sp_run
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = ();
	while (my ($name, $text) = each (%{$cmd_ref->{options}})) {
		my $value = check_text($text, $args_ref, $vars_ref,
			$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
		$args_ref->{$name} = $value;
	}
	return $info_ref;
}

sub check_sp_if
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = ();
	my $text = (exists $cmd_ref->{condition} ? $cmd_ref->{condition} : $cmd_ref->{text});
	my $value = check_text($text, $args_ref, $vars_ref,
		$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
	if (is_unresolved($value)) {
		# TODO: Only check the matched block if determined
	}
	my $cmd_info_ref = check_block($cmd_ref->{block}, $args_ref, $vars_ref);
	merge_info($info_ref, $cmd_info_ref, $cmd_ref);
	foreach my $else_ref (@{$cmd_ref->{else_if}}) {
		my $text = (exists $else_ref->{condition} ? $else_ref->{condition} : $else_ref->{text});
		my $value = check_text($text, $args_ref, $vars_ref,
			$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
		my $cmd_info_ref = check_block($else_ref->{block}, $args_ref, $vars_ref);
		merge_info($info_ref, $cmd_info_ref, $cmd_ref);
	}
	if (exists $cmd_ref->{else}) {
		my $cmd_info_ref = check_block($cmd_ref->{else}, $args_ref, $vars_ref);
		merge_info($info_ref, $cmd_info_ref, $cmd_ref);
	}
	return $info_ref;
}

sub check_sp_for
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = ();
	my $value = check_text($cmd_ref->{text}, $args_ref, $vars_ref,
		$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
	# TODO: Check for changing variables in parallel block
	my $cmd_info_ref = check_block($cmd_ref->{block}, $args_ref, $vars_ref);
	merge_info($info_ref, $cmd_info_ref);
	return $info_ref;
}

sub check_sp_while
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = ();
	my $value = check_text($cmd_ref->{condition}, $args_ref, $vars_ref,
		$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
	if (is_unresolved($value)) {
		# TODO: Only check the matched block if determined
	}
	my $cmd_info_ref = check_block($cmd_ref->{block}, $args_ref, $vars_ref);
	merge_info($info_ref, $cmd_info_ref);
	return $info_ref;
}

sub check_primitive
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = {};
	if ($cmd_ref->{primitive} eq 'SP_set') {
		$info_ref = check_sp_set($cmd_ref, $args_ref, $vars_ref);
	} elsif ($cmd_ref->{primitive} eq 'SP_run') {
		$info_ref = check_sp_run($cmd_ref, $args_ref, $vars_ref);
	} elsif ($cmd_ref->{primitive} eq 'SP_if') {
		$info_ref = check_sp_if($cmd_ref, $args_ref, $vars_ref);
	} elsif ($cmd_ref->{primitive} eq 'SP_for' or $cmd_ref->{primitive} eq 'SP_for_parallel') {
		$info_ref = check_sp_for($cmd_ref, $args_ref, $vars_ref);
	} elsif ($cmd_ref->{primitive} eq 'SP_while') {
		$info_ref = check_sp_while($cmd_ref, $args_ref, $vars_ref);
	}
	return $info_ref;
}

sub check_cmd
{
	my ($cmd_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = {};
	foreach my $type (@FILES_ATTR) {
		foreach my $text (keys %{$cmd_ref->{$type}}) {
			my $value = check_text($text, $args_ref, $vars_ref,
				$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
			# TODO: expand text to multiple-files
			if (is_unresolved($value)) {
				die "ERROR: Can not determine the $type file '$text' before running.\n"
					. "  at " . file_pos($cmd_ref) . "\n$die_msg_tailing";
			}
			$info_ref->{$type}{$value} = $text;
		}
	}
	if (exists $cmd_ref->{primitive}) {
		my $cmd_info_ref = check_primitive($cmd_ref, $args_ref, $vars_ref);
		merge_info($info_ref, $cmd_info_ref, $cmd_ref);
	} elsif (exists $cmd_ref->{block}) {
		my $cmd_info_ref = check_block($cmd_ref->{block}, $args_ref, $vars_ref);
		merge_info($info_ref, $cmd_info_ref, $cmd_ref);
	} else {
		check_text($cmd_ref->{command}, $args_ref, $vars_ref,
			$global_vars_ref->{$cmd_ref->{file}}, $info_ref);
	}
	return $info_ref;
}

sub check_block
{
	my ($block_ref, $args_ref, $vars_ref) = @_;
	my $info_ref = {};
	foreach my $cmd_ref (@{$block_ref->{commands}}) {
		# TODO: Check if the pipeline changes variables in parallel steps.
		my $cmd_info_ref = check_cmd($cmd_ref, $args_ref, $vars_ref);
		merge_info($info_ref, $cmd_info_ref, $cmd_ref);
	}
	return $info_ref;
}

sub check_proc
{
	# args_ref : options that passed from command line or SP_run
	# vars_ref : options that set by SP_set in procedures
	my ($proc_name, $args_ref, $vars_ref) = @_;
	my $info_ref = check_block($procs_ref->{$proc_name}, $args_ref, $vars_ref);
	foreach my $file (keys %{$info_ref->{output}}) {
		if (exists $info_ref->{require}{$file}) {
			delete $info_ref->{require}{$file};
		} elsif (exists $info_ref->{input}{$file}) {
			delete $info_ref->{input}{$file};
		} else {
			$info_ref->{'output.final'}{$file} = $info_ref->{output}{$file};
			delete $info_ref->{output}{$file};
		}
	}
	foreach my $type ('require', 'input') {
		foreach my $file (keys %{$info_ref->{$type}}) {
			if (exists $info_ref->{'output.temp'}{$file} or exists $info_ref->{'output.final'}{$file}) {
				delete $info_ref->{$type}{$file};
			}
		}
	}
	return $info_ref;
}

############################################################
# Run the pipeline

sub run_sp_set
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	my $name = $cmd_ref->{var_name};
	if (not exists $args_ref->{$name}) {
		my $value = eval_text_in_shell($cmd_ref->{text}, $indent, $args_ref, $proc_vars_ref,
			$global_vars_ref->{$cmd_ref->{file}});
		return undef if not defined $value;
		$proc_vars_ref->{$name} = $value;
	}
	return 0;
}

sub run_sp_run
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	my %options = %{$cmd_ref->{options}};
	foreach my $name (keys %options) {
		$options{$name} = eval_text_in_shell($options{$name}, $indent, $args_ref, $proc_vars_ref,
			$global_vars_ref->{$cmd_ref->{file}});
	}
	if (exists $cmd_ref->{dots}) {
		foreach my $name (keys %{$args_ref}) {
			$options{$name} = eval_text_in_shell($args_ref->{$name}, $indent, $args_ref, $proc_vars_ref,
				$global_vars_ref->{$cmd_ref->{file}});
		}
	}
	return run_proc($cmd_ref->{proc_name}, $indent, \%options);
}

sub run_sp_if
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	my $ret = 0;
	my $yes;
	my $cmd;
	my $run_id = get_new_run_id;
	foreach my $cond_ref (@{$cmd_ref->{condition}}) {
		if (exists $cond_ref->{bash}) {
			$cmd = "$cond_ref->{command} $cond_ref->{negative}($cond_ref->{bash})";
			my $cmd_result = eval_text($cond_ref->{bash}, $args_ref, $proc_vars_ref,
				$global_vars_ref->{$cmd_ref->{file}});
			$yes = run_checker($cmd, $cmd_result, $run_id, $cond_ref->{negative}, $indent);
			return undef if not defined $yes;
		} else {
			$cmd = "$cond_ref->{command} $cond_ref->{text}";
			my $s = eval_text_in_shell($cond_ref->{text}, $indent, $args_ref, $proc_vars_ref,
				$global_vars_ref->{$cmd_ref->{file}});
			return undef if not defined $s;
			$yes = ($s ne '');
			if (not $test_mode) {
				log_print "$indent($run_id) $cmd returns '" . ($yes ? 'yes' : 'no') . "'\n";
			}
		}
		if ($yes) {
			$ret = run_block($cmd_ref, $args_ref, $proc_vars_ref, $indent);
			last;
		}
	}
	if (not $yes and exists $cmd_ref->{else_block}) {
		$ret = run_block($cmd_ref->{else}, $args_ref, $proc_vars_ref, $indent);
	}
	return $ret;
}

sub run_sp_for
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	my $ret = 0;
	my $name = $cmd_ref->{variable};
	my $value = eval_text_in_shell($cmd_ref->{text}, $indent, $args_ref, $proc_vars_ref,
		$global_vars_ref->{$cmd_ref->{file}});
	return undef if not defined $value;
	if ($cmd_ref->{primitive} eq 'SP_for' or $max_thread_number == 1 or $test_mode) {
		foreach my $each_value (split(/\s+/, $value)) {
			$proc_vars_ref->{$name} = $each_value;
			$ret = run_block($cmd_ref, $args_ref, $proc_vars_ref, $indent);
			return undef if not defined $ret;
			last if $ret != 0;
		}
		delete $proc_vars_ref->{$name};
	} else {
		my @threads = ();
		foreach my $each_value (split(/\s+/, $value)) {
			my %thd_vars = %{$proc_vars_ref};
			$thd_vars{$name} = $each_value;
			push @threads, threads->create(\&run_block, $cmd_ref, $args_ref, \%thd_vars, $indent);
		}
		foreach my $thd (@threads) {
			my $thd_ret = $thd->join();
			if (not defined $thd_ret) {
				undef $ret;
			} elsif ($thd_ret ne 0) {
				$ret = $thd_ret if defined $ret;
			}
		}
		return undef if not defined $ret;
	}
	return $ret;
}

sub run_sp_while
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	my $ret = 0;
	my $run_id = get_new_run_id;
	my $cmd = "SP_while $cmd_ref->{negative}($cmd_ref->{bash})";
	while (1) {
		my $cmd_result = eval_text($cmd_ref->{bash}, $args_ref, $proc_vars_ref,
			$global_vars_ref->{$cmd_ref->{file}});
		my $yes = run_checker($cmd, $cmd_result, $run_id, $cmd_ref->{negative}, $indent);
		return undef if not defined $ret;
		last if (not $yes);
		$ret = run_block($cmd_ref, $args_ref, $proc_vars_ref, $indent);
		return undef if not defined $ret;
		last if $ret != 0;
	}
	return $ret;
}

sub run_primitive
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	if ($cmd_ref->{primitive} eq 'SP_set') {
		return run_sp_set(@_);
	} elsif ($cmd_ref->{primitive} eq 'SP_run') {
		return run_sp_run(@_);
	} elsif ($cmd_ref->{primitive} eq 'SP_if') {
		return run_sp_if(@_);
	} elsif ($cmd_ref->{primitive} eq 'SP_for' or $cmd_ref->{primitive} eq 'SP_for_parallel') {
		return run_sp_for(@_);
	} elsif ($cmd_ref->{primitive} eq 'SP_while') {
		return run_sp_while(@_);
	} else {
		die "ERROR: Unknown primitive '$cmd_ref->{primitive}'!\n$die_msg_tailing";
	}
}

sub run_cmd
{
	my ($cmd_ref, $args_ref, $proc_vars_ref, $indent) = @_;

	#   Since run_cmd may be started as in a new thread, copy the variable list
	# to record the changes, and after all return the copy to parent thread.
	my %proc_vars = %{$proc_vars_ref};
	my $ret = 0;

	if (exists $cmd_ref->{primitive}) {
		$ret = run_primitive($cmd_ref, $args_ref, \%proc_vars, $indent);
		return undef if not defined $ret;
	} elsif (exists $cmd_ref->{block}) {
		$ret = run_block($cmd_ref->{block}, $args_ref, \%proc_vars, $indent);
		return undef if not defined $ret;
	} else {
		# For single bash command
		if ($cmd_ref->{command} =~ /^export (\w+)=(.*)$/) {
			my $run_id = get_new_run_id;
			my $name = $1;
			my $value = eval_text_in_shell($2, $indent, $args_ref, \%proc_vars,
				$global_vars_ref->{$cmd_ref->{file}});
			return undef if not defined $value;
			log_print "$indent($run_id) [shell] export $name=$value\n";
			{
				lock(%shell_env_vars);
				$shell_env_vars{$name} = $value;
			}
		} else {
			my $run_id = get_new_run_id;
			my $cmd_result = eval_text($cmd_ref->{command}, $args_ref, \%proc_vars,
				$global_vars_ref->{$cmd_ref->{file}});
			my @cmd_lines = split("\n", $cmd_result);
			$cmd_result = join("\\\n", @cmd_lines);
			foreach my $cmd_line (@cmd_lines) {
				$cmd_line =~ s/^\s+//g;
				$cmd_line =~ s/\s+$//g;
			}
			my $cmd_result_in_one_line = join(' ', @cmd_lines);

			if (not $test_mode) {
				log_print "$indent($run_id) [shell] $cmd_result_in_one_line\n";

				my $info_ref = { requires => {}, inputs => {}, outputs => {}, saves => {}, temps => {} };
				foreach my $require (keys %{$cmd_ref->{requires}}) {
					my $file = eval_text($require, $args_ref, \%proc_vars,
						$global_vars_ref->{$cmd_ref->{file}});
					$info_ref->{requires}{$file} = '';
				}
				foreach my $input (keys %{$cmd_ref->{inputs}}) {
					my $file = eval_text($input, $args_ref, \%proc_vars,
						$global_vars_ref->{$cmd_ref->{file}});
					$info_ref->{inputs}{$file} = '';
				}
				foreach my $output (keys %{$cmd_ref->{outputs}}) {
					my $file = eval_text($output, $args_ref, \%proc_vars,
						$global_vars_ref->{$cmd_ref->{file}});
					$info_ref->{outputs}{$file} = '';
				}
				foreach my $save (keys %{$cmd_ref->{saves}}) {
					my $file = eval_text($save, $args_ref, \%proc_vars,
						$global_vars_ref->{$cmd_ref->{file}});
					$info_ref->{saves}{$file} = '';
				}
				foreach my $temp (keys %{$cmd_ref->{temps}}) {
					my $file = eval_text($temp, $args_ref, \%proc_vars,
						$global_vars_ref->{$cmd_ref->{file}});
					$info_ref->{temps}{$file} = '';
				}
				my $chk_ret = chk_files($info_ref, $indent, $run_id);
				if ($chk_ret < 0) {
					return { ret => $chk_ret, vars => \%proc_vars };
				} elsif ($chk_ret > 0) {
					log_print "$indent($run_id) [skip] $cmd_ref->{command}\n";
					return { ret => 0, vars => \%proc_vars };
				}

				if ($max_thread_number > 1) {
					LOOP: while (1) {
						{
							lock($thread_number);
							if ($thread_number < $max_thread_number) {
								$thread_number++;
								last LOOP;
							}
						}
						sleep 1;
					}
				}
			}

			$ret = run_shell($cmd_result, '', $cmd_ref->{name}, $run_id, $indent);
			if ($max_thread_number > 1) {
				lock($thread_number);
				$thread_number--;
			}
			return undef if not defined $ret;
			if (not $test_mode and $ret != 0) {
				foreach my $output (keys %{$cmd_ref->{outputs}}) {
					my $file = eval_text($output, $args_ref, \%proc_vars,
						$global_vars_ref->{$cmd_ref->{file}});
					if (-e $file) {
						log_print "$indent($run_id) removes bad output file '$file'!\n";
						unlink $file;
					}
				}
			}
		}
	}
	return { ret => $ret, vars => \%proc_vars };
}

sub run_block
{
	my ($block_ref, $args_ref, $proc_vars_ref, $indent) = @_;
	my $ret = 0;
	my @cmds = @{$block_ref->{commands}};
	if ($test_mode) {
		foreach my $cmd_ref (@cmds) {
			my $cmd_ret = run_cmd($cmd_ref, $args_ref, $proc_vars_ref, $indent . '  ');
			if (not defined $cmd_ret) {
				undef $ret;
				last;
			}
			$ret = $cmd_ret->{ret};
			foreach my $name (keys %{$cmd_ret->{vars}}) {
				$proc_vars_ref->{$name} = $cmd_ret->{vars}->{$name};
			}
		}
	} else {
		my @thread_list = ();
		foreach my $cmd_ref (@cmds) {
			if ($can_use_threads and $max_thread_number != 1) {
				my $thd = threads->create({'context' => 'list'}, \&run_cmd,
					$cmd_ref, $args_ref, $proc_vars_ref, $indent . '  ');

				if ($block_ref->{parallel}) {
					push @thread_list, $thd;
				} else {
					my $thread_ret = $thd->join();
					if (not defined $ret) {
						undef $ret;
						last;
					}
					$ret = $thread_ret->{ret};
					foreach my $name (keys %{$thread_ret->{vars}}) {
						$proc_vars_ref->{$name} = $thread_ret->{vars}->{$name};
					}
				}
			} else {
				my $cmd_ret = run_cmd($cmd_ref, $args_ref, $proc_vars_ref, $indent . '  ');
				if (not defined $cmd_ret) {
					undef $ret;
					last;
				}
				$ret = $cmd_ret->{ret};
				foreach my $name (keys %{$cmd_ret->{vars}}) {
					$proc_vars_ref->{$name} = $cmd_ret->{vars}->{$name};
				}
			}
			last if not defined $ret or $ret != 0;
		}
		if (scalar @thread_list > 0) {
			foreach my $thd (@thread_list) {
				my $thd_ret = $thd->join();
				if (not defined $thd_ret) {
					undef $ret;
				} elsif ($thd_ret->{ret} != 0) {
					$ret = $thd_ret->{ret} if defined $ret;
				} else {
					foreach my $name (keys %{$thd_ret->{vars}}) {
						$proc_vars_ref->{$name} = $thd_ret->{vars}->{$name};
					}
				}
			}
			@thread_list = ();
		}
		return $ret;
	}
}

sub run_proc
{
	my ($proc_name, $args_ref, $indent) = @_;

	my $proc_ref = $procs_ref->{$proc_name};
	my %proc_vars = ();

	my $cmd = "$proc_name";
	$cmd .= " $_=$args_ref->{$_}" foreach (keys%{$args_ref});

	my $run_id;
	my $start_time;
	my $ret = 0;
	if (not $test_mode) {
		$run_id = get_new_run_id;
		$start_time = time;
		log_print "$indent($run_id) [pipeline] $cmd\n";
	}
	
	my $info_ref = check_proc($proc_name, $args_ref, \%proc_vars);
	
	if (not $test_mode) {
		$ret = chk_files($info_ref, $indent, $run_id);
		return $ret if $ret < 0;
		if ($ret > 0) {
			log_print "$indent($run_id) [skip] $cmd\n";
			return 0;
		}
		log_print "$indent($run_id) starts at " . time_string($start_time) . "\n";
	}

	if ($test_mode) {
		run_block($proc_ref, $args_ref, \%proc_vars, $indent);
		return 1;
	} else {
		$ret = run_block($proc_ref, $args_ref, \%proc_vars, $indent);
		
		if (defined $ret and $ret == 0 and not $keep_temps) {

			# When successeed, remove intermediate files
			foreach my $item (keys %{$proc_ref->{temps}}) {
				my $file = eval_text($item, $args_ref, \%proc_vars,
					$global_vars_ref->{$proc_ref->{file}});
				if (-e $file) {
					log_printf "$indent($run_id) removes intemediate file '%s'\n", $file;
					unlink $file;
				}
			}
		}

		# Record the finish time
		my $end_time = time;
		log_printf "$indent($run_id) ends at %s (elapsed: %s)\n",
			time_string($end_time), time_elapse_string($start_time, $end_time);
		
		return $ret;
	}
}

sub run_sysinfo
{
	my ($proc_name) = @_;
	my @cmds = ();
	foreach my $cmd_ref (@{$procs_ref->{$proc_name}->{commands}}) {
		my $cmd = check_text($cmd_ref->{command}, (), (),
			$global_vars_ref->{$cmd_ref->{file}}, {});
		push @cmds, join("\\\n", split("\n", $cmd));
	}
	if (open SHELL, '|-', $shell) {
		print SHELL join("\n", '(', @cmds, ') 2>&1 >>' . LOG_DIR . '/sysinfo');
		close SHELL;
	}
}

############################################################
# Help messages

sub print_usage
{
	print '
SeqPipe: a SEQuencing data analsysis PIPEline framework
Version: 0.5.0 ($Rev$)
Author : Linlin Yan (yanll<at>mail.cbi.pku.edu.cn)
Copyright: 2012-2013, Centre for Bioinformatics, Peking University, China
Websites: http://seqpipe.googlecode.com
          http://www.cbi.pku.edu.cn

Usage: seqpipe [options] <procedure> [NAME=VALUE ...]

Options:
   -h / -H         Show help messages.
   -l [<pattern>]  List current available procedures.
   -m <file>       Load procedure module file, this option can be used many times.
   -D              Disable to load default pipelines.
   -t <int>        Max thread number in parallel. default: ' . $max_thread_number . '
   -e <cmd>        Inline mode, execute a bash command directly.
   -s <shell>      Send commands to another shell (such as "qsub_sync"), default: ' . $shell . '
   -k              Keep intermediate files.
   -R              Show the raw procedure declaration.
   -T              Test mode, show commands rather than execute them.

';
}

############################################################
# Main program start from here.

# Parse command line
my $proc_name = '';
my $args_ref = {};
$help_mode = 1 if $#ARGV < 0;
while (my $arg = shift @ARGV) {
	if ($arg eq '-h') {
		$help_mode = 1;
	} elsif ($arg eq '-H') {
		$help_mode = 2;
	} elsif ($arg eq '-v') {
		++$verbose;
		$die_msg_tailing = 'Failed';
	} elsif ($arg eq '-m') {
		die "ERROR: Missing argument for '$arg' option!\n" if $#ARGV < 0;
		push @files, abs_path(shift @ARGV);
	} elsif ($arg eq '-D') {
		$auto_load = 0;
	} elsif ($arg eq '-l') {
		$list_mode = 1;
	} elsif ($arg eq '-T') {
		$test_mode = 1;
	} elsif ($arg eq '-R') {
		$show_mode = 1;
	} elsif ($arg eq '-k') {
		$keep_temps = 1;
	} elsif ($arg eq '-t') {
		die "ERROR: Missing argument for '$arg' option!\n" if $#ARGV < 0;
		$max_thread_number = shift @ARGV;
		die "ERROR: Invalid max thread number: $max_thread_number!\n" if $max_thread_number <= 0;
		if ($max_thread_number > 1 and not $can_use_threads) {
			print "WARNING: Parallel mode is disabled since your Perl does not support threads!\n";
		}
	} elsif ($arg eq '-e') {
		die "ERROR: Missing argument for '$arg' option!\n" if $#ARGV < 0;
		my $cmd = shift @ARGV;
		die "ERROR: Empty inline command is not allowed!\n" if $cmd =~ /^\s*$/;
		die "ERROR: Multi-line inline command is not allowed!\n" if $cmd =~ /\n/;
		push @exec_cmds, $cmd;
	} elsif ($arg eq '-s') {
		die "ERROR: Missing argument for '$arg' option!\n" if $#ARGV < 0;
		$shell = shift @ARGV;
		die "ERROR: Empty shell command is not allowed!\n" if $shell =~ /^\s*$/;
		my $qsub_sync = APP_ROOT . '/qsub_sync';
		$shell =~ s/^qsub(\s.*|)/$qsub_sync$1/;
	} else {
		die "ERROR: Unknown option '$arg'!\n" if $arg =~ /^-/;
		if ($arg =~ /^(\w+)=(.*)$/) {
			die "ERROR: duplicated option '$1'!\n" if exists $args_ref->{$1};
			my $name = $1;
			$args_ref->{$name} = $2;
			die "ERROR: Invalid option '$name'! Option name starts with '_' is reserved.\n" if $name =~ /^_/;
		} else {
			die "ERROR: Invalid format of option: $arg\n" if $proc_name or @exec_cmds;
			$proc_name = $arg;
		}
	}
}
die "ERROR: Can not use both '-e' and '<proc_name>'!\n" if $proc_name and @exec_cmds;

# Load modules
@files = (glob(APP_ROOT . '/*.pipe'), @files) if $auto_load;
load_module($_, $args_ref) foreach (@files);

# List procedures
if ($list_mode) {
	list_proc($proc_name);
	exit 1;
}

# Prepare for inline mode
if (@exec_cmds) {
	$procs_ref->{''} = { name => '', file => '' };
	my $line_no = 0;
	foreach my $cmd (@exec_cmds) {
		++$line_no;
		push @{$procs_ref->{''}->{commands}}, { name => 'shell', file => '', line_no => $line_no, command => $cmd };
	}
} elsif ($proc_name) {
	die "ERROR: Unknown procedure '$proc_name'! Use '-l' to list available procedures.\n"
		unless exists $procs_ref->{$proc_name};
} else {
	print "ERROR: No procedure name provided!\n" unless $help_mode;
	print_usage;
	exit 1;
}

# Show pipeline scripts
if ($show_mode) {
	show_proc($proc_name, $args_ref);
	exit 1;
}

# Check variables and dependencies
my $info_ref = check_proc($proc_name, $args_ref, {});
if ($help_mode) {
	show_info($proc_name, $info_ref);
	exit 1;
}

# Write log files
if (not $test_mode) {
	if (exists $info_ref->{req_vars} and %{$info_ref->{req_vars}}) {
		die 'ERROR: Variable(s) required for ' . ($proc_name ? "procedure '$proc_name'" : "inline command")
			. ":\n   " . join(', ', sort keys %{$info_ref->{req_vars}}) . "\n";
	}
	die "ERROR: Can not run internal procedures '$proc_name' directly!\n" if $proc_name =~ /^_/;
	# Prepare log directory
	mkdir LOG_ROOT or die "ERROR: Can not create directory '" . LOG_ROOT . "'!" unless -d LOG_ROOT;
	mkdir LOG_DIR or die "ERROR: Can not create directory '" . LOG_DIR . "'!";
	system "ln -s -f -n " . UNIQ_ID . " " . LOG_ROOT . "/last";
	# Write whole command line to log
	open LOG_FILE, '>>', LOG_ROOT . '/history.log';
	log_print UNIQ_ID . "\t$command_line\n";
	close LOG_FILE;
	# Prepare log file
	open LOG_FILE, '|-', 'tee -ai ' . LOG_DIR . '/log';
	log_print '[' . UNIQ_ID . "] $command_line\n";
	# Write sysinfo log
	foreach my $name (keys %{$procs_ref}) {
		if ($name =~ /_sysinfo$/) {
			if ($name eq '_sysinfo' or ($proc_name and $procs_ref->{$name}{file} eq $procs_ref->{$proc_name}{file})) {
				run_sysinfo($name);
			}
		}
	}
}

# Run the pipeline
my $ret = run_proc($proc_name, $args_ref, '');
if (not $test_mode) {
	if (not defined $ret) {
		log_print "Pipeline aborted!\n";
	} elsif ($ret != 0) {
		log_print "Pipeline finished abnormally with exit value: $ret!\n";
	} else {
		log_print "Pipeline finished successfully!\n";
	}
	close LOG_FILE;
}
exit (defined $ret ? $ret : 1);
