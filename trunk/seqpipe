#!/usr/bin/perl -w
use strict;
use warnings;
use File::Basename;
use Cwd 'abs_path';

my $help_mode = 0;
my $help_detail_mode = 0;
my $verbose = 0;
my $list_mode = 0;
my $test_mode = 0;

my %modules;
my %global_variables;
my $run_counter = 0;

my $seqpipe_log_dir = "./.seqpipe";
my $default_dir_attr = 0755;

my $return_value = 0;
my @module_files = ( (dirname abs_path $0) . "/default.pipe" );
my $command_line = "$0" . ($#ARGV >= 0 ? " " : "") . join(" ", @ARGV);

sub append_command
{
	my ($commands_ref, $variables_ref, $command) = @_;

	push(@{$commands_ref}, $command);
	while ($command =~ /\${(\w+)}/g) {
		my $command_name = $1;
		if (!exists ${$variables_ref}{$command_name}) {
			${$variables_ref}{$command_name} = '';
		}
	}
}

sub load_module
{
	my ($module_file) = @_;
	my $before_functions = 1;
	my $line;
	my $last_line;

	open MODULE_FILE, $module_file or die "Can not open module file '$module_file'!";
	print "Load module file '$module_file'\n" if ($verbose);
	while ($line = <MODULE_FILE>) {
		chomp $line;

		if ($line eq '#[pipeline]') {
			while ($line = <MODULE_FILE>) {
				if ($line =~ /^function\s+(\w+)\s*$/) {
					$before_functions = 0;

					my $pipeline_name = $1;
					my @commands = ();
					my %variables = ();

					$line = <MODULE_FILE>;
					chomp $line;
					if ($line ne "{") {
						die "Invalid function(module) declaration!";
					}

					while ($line = <MODULE_FILE>) {
						chomp $line;
						if ($line eq "}") { last; }
						$line =~ s/^\s*//g;
						if ($line =~ s/\\$//) {
							$last_line = $last_line . $line;
						} else {
							$last_line = $last_line . $line;
							if (!($last_line =~ /^\s*$/)) {
								append_command \@commands, \%variables, $last_line;
							}
							$last_line = "";
						}
					}
					if ($line ne "}") {
						die "Invalid function(module) declaration!";
					}
					if ($last_line ne "") {
						append_command \@commands, \%variables, $last_line;
					}
					
					$modules{$pipeline_name} = { commands => \@commands, variables => \%variables };
				} elsif ($line =~ /^\s*function\s+/) {
					die "Invalid function(module) declaration!";
				}
			}
		} elsif ($line =~ /^\s*function\s*\w*/) {
			$before_functions = 0;
		} elsif ($line =~ /\s*(\w+)=(.*)$/) {
			if ($before_functions) {
				my $option_name = $1;
				my $option_value = $2;
				$option_value =~ s/\s*#.*$//g;
				if (exists $global_variables{$option_name}) {
					print "Warning: duplicated declaration of global variable '$option_name'\n";
				} else {
					while ($option_value =~ /\${(\w+)}/g) {
						if (exists $global_variables{$option_name}) {
							$option_value =~ s/\${$option_name}/$global_variables{$option_name}/g;
						} else {
							$option_value =~ s/\${$option_name}//g;
						}
					}
					$global_variables{$option_name} = $option_value;
				}
			}
		}
	}
	close MODULE_FILE;
}

sub print_usage
{
	print '
SeqPipe: a SEQuencing data analsysis PIPEline framework
Version: 0.1.0 ($Rev$)
Copyright: 2012, Centre for Bioinformatics, Peking University, China

Usage: ' . basename($0) . ' [options] <pipeline> [pipeline-options]

Options:
   -h           Show this help.
   -H           Show detail help (including optional parameters).
   -v           Show verbose message.
   -m <file>    Load pipeline modules, this option can be used many times.
   -l           List current available pipelines.
   -t           Test mode, only print the commands rather than execute them.
';
}

sub list_pipelines
{
	print "
Current available pipelines:
";
	foreach my $pipeline (sort keys %modules) {
		print "   $pipeline\n";
	}
	print "\n";
}

sub check_option
{
	my ($pipeline_name, $variable_name) = @_;

	if (exists ${$modules{$pipeline_name}{variables}}{$variable_name}) {
		return 1;
	}
	foreach my $command (@{$modules{$pipeline_name}{commands}}) {
		if ($command =~ /^SP_run\s+(\w+)\s+/) {
			if (check_option($1, $variable_name)) {
				return 1;
			}
		}
	}
	return 0;
}

sub parse_line {
	my ($line) = @_;
	my $i = 0;
	my @parts = ();
	my $word = '';
	my $quot = '';

	while ($line ne '') {
		my $c = substr($line, 0, 1);
		$line = substr($line, 1);
		if ($c =~ /\s/) {
			push @parts, $word if ($word ne '');
			$word = '';
		} elsif ($c =~ /[\'\"]/) {
			$quot = $c;
			$word .= $c;
			while ($line ne '') {
				my $c = substr($line, 0, 1);
				$line = substr($line, 1);
				$word .= $c;
				if ($c eq '\\') {
					$c = substr($line, 0, 1);
					$line = substr($line, 1);
					$word .= $c;
					next;
				}
				if ($c eq $quot) { last; }
			}
		} else {
			$word .= $c;
		}
	}
	push @parts, $word if ($word ne '');
	return @parts;
}

sub run_pipeline
{
	my ($pipeline, $argv_ref) = @_;

	if (!exists $modules{$pipeline}) {
		print "Error: Unknown pipeline '$pipeline'! Use '-l' option to list available pipelines.\n";
		exit 1;
	}

	my %changable_variables;
	foreach my $command (@{$modules{$pipeline}{commands}}) {
		if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
			$changable_variables{$1} = $2;
		}
	}

	my %variables = %{$modules{$pipeline}{variables}};
	foreach my $arg (keys %variables) {
		if (exists $global_variables{$arg} and $global_variables{$arg} ne "") {
			$variables{$arg} = $global_variables{$arg};
		}
	}
	foreach my $arg (keys %variables) {
		if (exists $ENV{$arg} and $ENV{$arg} ne "") {
			$variables{$arg} = $ENV{$arg}
		}
	}
	foreach my $arg (@{$argv_ref}) {
		if ($arg =~ /^(\w+)=(.*)$/) {
			my $option_name = $1;
			my $option_value = $2;

#			if (!check_option($pipeline, $option_name)) {
#				print "Error: Unknown option '$option_name'!\n";
#				exit 1;
#			}
			$variables{$option_name} = $option_value;
		} else {
			print "Error: Invalid pipeline option '$arg'! It should be the format of 'NAME=VALUE'!\n";
			exit 1;
		}
	}
	foreach my $arg (sort keys %variables) {
		if ($variables{$arg} eq "" and !exists $changable_variables{$arg}) {
			print "Error: Option '$arg' is required!\n";
			exit 1;
		}
	}

	if ($test_mode) {
		foreach my $command (@{$modules{$pipeline}{commands}}) {
			while ($command =~ /\${(\w+)}/) {
				my $option_name = $1;
				$command =~ s/\${$option_name}/$variables{$option_name}/g;
			}

			if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
				if ($verbose) {
					print "$command\n";
				}
				if (eval "$3") {
					$variables{$1} = $2;
					if ($verbose) {
						print "# Option '$1' changes to '$2'.\n";
					}
				}
			} elsif ($command =~ /^SP_run\s+(\w+)/) {
				if ($verbose) {
					print "$command\n";
				}
				my @pipeline_options = parse_line($command);
				shift @pipeline_options;
				my $pipeline_name = shift @pipeline_options;
				push @pipeline_options, @{$argv_ref};
				run_pipeline($pipeline_name, \@pipeline_options);
			} else {
				print "$command\n";
			}
		}
		return 0;
	}

	foreach my $command (@{$modules{$pipeline}{commands}}) {
		while ($command =~ /\${(\w+)}/) {
			my $option_name = $1;
			$command =~ s/\${$option_name}/$variables{$option_name}/g;
		}

		if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
			if (eval "$3") {
				$variables{$1} = $2;
				print LOG_FILE "[SeqPipe] Option '$1' changes to '$2'.\n";
			}
			next;
		} elsif ($command =~ /^SP_run\s+(\w+)/) {
			my @pipeline_options = parse_line($command);
			shift @pipeline_options;
			my $pipeline_name = shift @pipeline_options;
			push @pipeline_options, @{$argv_ref};
			run_pipeline($pipeline_name, \@pipeline_options);
			next;
		}
		$run_counter += 1;
		print LOG_FILE "[SeqPipe] Command($$.$run_counter) line: $command\n";

		my $start_time = time;
		my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($start_time);
		printf LOG_FILE "[SeqPipe] Command($$.$run_counter) starts at %04d-%02d-%02d %02d:%02d:%02d\n",
			$year + 1900, $mon + 1, $mday, $hour, $min, $sec;

		foreach my $ext ("log", "err") {
			open FILE, ">>" . "$seqpipe_log_dir/$$.$run_counter.$ext";
			printf FILE "[SeqPipe] $command\n";
			close FILE;
		}

		system("/bin/bash", "-c",
			"($command) >>$seqpipe_log_dir/$$.$run_counter.log 2>>$seqpipe_log_dir/$$.$run_counter.err");
		if ($? == -1) {
			print LOG_FILE "[SeqPipe] Command($$.$run_counter) starts failed!\n";
			close LOG_FILE;
			exit 1;
		} elsif ($? & 127) {
			print LOG_FILE "[SeqPipe] Command($$.$run_counter) starts failed! Child died with signal %d, %s coredump\n",
				($? & 127), ($? & 128) ? 'with' : 'without';
			close LOG_FILE;
			exit 1;
		} else {
			$return_value = ($? >> 8);
		}

		my $end_time = time;
		my $elapsed_time = $end_time - $start_time;
		my $time_text = "";
		if ($elapsed_time >= 86400) {
			$time_text .= ($elapsed_time / 86400) . "d ";
			$elapsed_time %= 86400;
		}
		if ($time_text ne "" or $elapsed_time >= 3600) {
			$time_text .= ($elapsed_time / 3600) . "h ";
			$elapsed_time %= 3600;
		}
		if ($time_text ne "" or $elapsed_time >= 60) {
			$time_text .= ($elapsed_time / 3600) . "m ";
			$elapsed_time %= 60;
		}
		if ($time_text eq "" or $elapsed_time > 0) {
			$time_text .= $elapsed_time . "s ";
		}
		$time_text =~ s/\s$//g;
		($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($end_time);
		printf LOG_FILE "[SeqPipe] Command($$:$run_counter) ends at %04d-%02d-%02d %02d:%02d:%02d (elapsed: %s)\n",
			$year + 1900, $mon + 1, $mday, $hour, $min, $sec, $time_text;
		
		if ($return_value != 0) {
			print LOG_FILE "[SeqPipe] Command($$:$run_counter) returns $return_value\n";
			last;
		}
	}
	return $return_value;
}

my $pipeline = "";

if ($#ARGV < 0) {
	$help_mode = 1;
} else {
	while (my $arg = shift @ARGV) {
		if ($arg eq '-h') {
			$help_mode = 1;
		} elsif ($arg eq '-H') {
			$help_mode = 1;
			$help_detail_mode = 1;
		} elsif ($arg eq '-v') {
			$verbose = 1;
		} elsif ($arg eq '-l') {
			$list_mode = 1;
		} elsif ($arg eq '-t') {
			$test_mode = 1;
		} elsif ($arg eq '-m') {
			if ($#ARGV < 0) {
				print "Error: missing argument for option '$arg'!\n";
				exit 1;
			}
			push(@module_files, shift @ARGV);
		} elsif ($arg =~ '^-') {
			print "Error: Unknown option '$arg'!\n";
			exit 1;
		} else {
			$pipeline = $arg;
			last;
		}
	}
}
foreach my $arg (@ARGV) {
	if ($arg eq "-h") {
		$help_mode = 1;
		last;
	} elsif ($arg eq "-H") {
		$help_mode = 1;
		$help_detail_mode = 1;
		last;
	}
}
if ($pipeline eq "") {
	$help_mode = 1;
}

foreach my $module_file (@module_files) {
	load_module $module_file;
}
if ($verbose) {
	printf "All %d files (%d modules) loaded.\n",
		scalar @module_files, scalar keys %modules;
}

if ($list_mode) {
	list_pipelines;
	exit 1;
}
if ($help_mode and $pipeline eq "") {
	print_usage;
	print "\n";
	exit 1;
}

if ($help_mode) {
	if (!exists $modules{$pipeline}) {
		print "Error: Unknown pipeline '$pipeline'! Use '-l' option to list available pipelines.\n";
		exit 1;
	}

	my %changable_variables;
	foreach my $command (@{$modules{$pipeline}{commands}}) {
		if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
			$changable_variables{$1} = $2;
		}
	}

	print_usage;
	print "
Options for pipeline '$pipeline':
";
	for my $required (1,0) {
		foreach my $variable_name (sort keys %{$modules{$pipeline}{variables}}) {
			my $default_value = "";
			if (${$modules{$pipeline}{variables}}{$variable_name} ne "") {
				$default_value = ${$modules{$pipeline}{variables}}{$variable_name};
			} elsif (exists $global_variables{$variable_name} and $global_variables{$variable_name} ne "") {
				$default_value = $global_variables{$variable_name};
			}

			if (($required and $default_value eq "" and !exists $changable_variables{$variable_name})
					or (!$required and ($default_value ne "" or exists $changable_variables{$variable_name}))) {
				printf "   %-30s %s\n", $variable_name,
					(($default_value eq "" and !exists $changable_variables{$variable_name})
					? "Required" : "Def: " . $default_value);
			}
		}
		if (!$help_detail_mode) { last; }
	}
	exit 1;
}

mkdir $seqpipe_log_dir, $default_dir_attr unless (-d $seqpipe_log_dir);

open LOG_FILE, ">>" . $seqpipe_log_dir . "/history.log";
printf LOG_FILE "%d\t%s\n", $$, $command_line;
close LOG_FILE;

if (!$test_mode) {
	open LOG_FILE, "| tee -ai " . $seqpipe_log_dir . "/$$.log";
}

run_pipeline $pipeline, \@ARGV;

if (!$test_mode) {
	close LOG_FILE;
}

exit $return_value;
