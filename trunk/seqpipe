#!/usr/bin/perl -w
use strict;
use warnings;
use File::Basename;
use File::stat;
use Cwd 'abs_path';

my $help_mode = 0;
my $help_detail_mode = 0;
my $verbose = 0;
my $list_mode = 0;
my $test_mode = 0;

my %modules;
my %global_variables = ( SEQPIPE => 'seqpipe' );
my $run_counter = 0;

my $seqpipe_log_dir = "./.seqpipe";
my $default_dir_attr = 0755;

my $return_value = 0;
my @module_files = ( (dirname abs_path $0) . "/default.pipe" );
my $command_line = "$0" . ($#ARGV >= 0 ? " " : "") . join(" ", @ARGV);

sub append_command
{
	my ($commands_ref, $variables_ref, $command) = @_;

	push(@{$commands_ref}, $command);
	while ($command =~ /\${(\w+)}/g) {
		my $command_name = $1;
		if (!exists ${$variables_ref}{$command_name}) {
			${$variables_ref}{$command_name} = '';
		}
	}
}

sub load_module
{
	my ($module_file) = @_;
	my $before_functions = 1;
	my $line;
	my $last_line;

	open MODULE_FILE, $module_file or die "Can not open module file '$module_file'!";
	print "Load module file '$module_file'\n" if ($verbose);
	while ($line = <MODULE_FILE>) {
		chomp $line;

		if ($line eq '#[procedure]') {
			my @inputs = ();
			my @outputs = ();
			my @requires = ();
			my $skip_record = "N";
			my $ignore_retval = "N";
			while ($line = <MODULE_FILE>) {
				if ($line =~ /^#\[workflow\s+(input|output|require|skip_record|ignore_retval)=.*\]$/) {
					while ($line =~ /\s+(input|output|require|skip_record|ignore_retval)="(.*?)"/g) {
						if ($1 eq "input") {
							push @inputs, $2;
						} elsif ($1 eq "output") {
							push @outputs, $2;
						} elsif ($1 eq "require") {
							push @requires, $2;
						} elsif ($1 eq "skip_record" or $1 eq "ignore_retval") {
							if ($2 ne "Y" and $2 ne "N") {
								die "Invalid value of '$1' attribute! Available values are: 'Y', 'N'";
							}
							if ($1 eq "skip_record") {
								$skip_record = $2;
							} else {
								$ignore_retval = $2;
							}
						}
					}
				} elsif ($line =~ /^function\s+(\w+)\s*$/) {
					$before_functions = 0;

					my $procedure_name = $1;
					my @commands = ();
					my %variables = ();

					$line = <MODULE_FILE>;
					chomp $line;
					if ($line ne "{") {
						die "Invalid function(module) declaration!";
					}
					$last_line = "";

					while ($line = <MODULE_FILE>) {
						chomp $line;
						if ($line eq "}") { last; }
						$line =~ s/^\s*//g;
						if ($line =~ s/\\$//) {
							$last_line = $last_line . $line;
						} else {
							$last_line = $last_line . $line;
							if (!($last_line =~ /^\s*$/)) {
								append_command \@commands, \%variables, $last_line;
							}
							$last_line = "";
						}
					}
					if ($line ne "}") {
						die "Invalid function(module) declaration!";
					}
					if ($last_line ne "") {
						append_command \@commands, \%variables, $last_line;
					}
					
					if ($procedure_name eq "sysinfo") {
						$skip_record = "Y";
						$ignore_retval = "Y";
					}

					$modules{$procedure_name} = {
						inputs        => \@inputs,
						outputs       => \@outputs,
						requires      => \@requires,
						commands      => \@commands,
						variables     => \%variables,
						skip_record   => $skip_record,
						ignore_retval => $ignore_retval
					};
					last;
				} elsif ($line =~ /^\s*function\s+/) {
					die "Invalid function(module) declaration!";
				}
			}
		} elsif ($line =~ /^\s*function\s*\w*/) {
			$before_functions = 0;
		} elsif ($line =~ /\s*(\w+)=(.*)$/) {
			if ($before_functions) {
				my $option_name = $1;
				my $option_value = $2;
				$option_value =~ s/\s*#.*$//g;
				if (exists $global_variables{$option_name}) {
					print "Warning: duplicated declaration of global variable '$option_name'\n";
				} else {
					while ($option_value =~ /\${(\w+)}/g) {
						if (exists $global_variables{$option_name}) {
							$option_value =~ s/\${$option_name}/$global_variables{$option_name}/g;
						} else {
							$option_value =~ s/\${$option_name}//g;
						}
					}
					$global_variables{$option_name} = $option_value;
				}
			}
		}
	}
	close MODULE_FILE;
}

sub print_usage
{
	print '
SeqPipe: a SEQuencing data analsysis PIPEline framework
Version: 0.1.0 ($Rev$)
Copyright: 2012, Centre for Bioinformatics, Peking University, China

Usage: ' . basename($0) . ' [options] <procedure> [procedure-options]

Options:
   -h           Show this help.
   -H           Show detail help (including optional parameters).
   -v           Show verbose message.
   -m <file>    Load procedure modules, this option can be used many times.
   -l           List current available procedures.
   -t           Test mode, only print the commands rather than execute them.
';
}

sub list_procedures
{
	print "
Current available procedures:
";
	foreach my $procedure (sort keys %modules) {
		print "   $procedure\n";
	}
	print "\n";
}

sub check_option
{
	my ($procedure_name, $variable_name) = @_;

	if (exists ${$modules{$procedure_name}{variables}}{$variable_name}) {
		return 1;
	}
	foreach my $command (@{$modules{$procedure_name}{commands}}) {
		if ($command =~ /^SP_run\s+(\w+)\s+/) {
			if (check_option($1, $variable_name)) {
				return 1;
			}
		}
	}
	return 0;
}

sub parse_line {
	my ($line) = @_;
	my $i = 0;
	my @parts = ();
	my $word = '';
	my $quot = '';

	while ($line ne '') {
		my $c = substr($line, 0, 1);
		$line = substr($line, 1);
		if ($c =~ /\s/) {
			push @parts, $word if ($word ne '');
			$word = '';
		} elsif ($c =~ /[\'\"]/) {
			$quot = $c;
			$word .= $c;
			while ($line ne '') {
				my $c = substr($line, 0, 1);
				$line = substr($line, 1);
				$word .= $c;
				if ($c eq '\\') {
					$c = substr($line, 0, 1);
					$line = substr($line, 1);
					$word .= $c;
					next;
				}
				if ($c eq $quot) { last; }
			}
		} else {
			$word .= $c;
		}
	}
	push @parts, $word if ($word ne '');
	return @parts;
}

sub run_procedure
{
	my ($procedure, $argv_ref) = @_;

	if (!exists $modules{$procedure}) {
		print "Error: Unknown procedure '$procedure'! Use '-l' option to list available procedures.\n";
		exit 1;
	}

	my %changable_variables;
	foreach my $command (@{$modules{$procedure}{commands}}) {
		if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
			$changable_variables{$1} = $2;
		}
	}

	my %variables = %{$modules{$procedure}{variables}};
	foreach my $arg (keys %variables) {
		if (exists $global_variables{$arg} and $global_variables{$arg} ne "") {
			$variables{$arg} = $global_variables{$arg};
		}
	}
	foreach my $arg (keys %variables) {
		if (exists $ENV{$arg} and $ENV{$arg} ne "") {
			$variables{$arg} = $ENV{$arg}
		}
	}
	foreach my $arg (@{$argv_ref}) {
		if ($arg =~ /^(\w+)=(.*)$/) {
			my $option_name = $1;
			my $option_value = $2;

			$variables{$option_name} = $option_value;
		} else {
			print "Error: Invalid procedure option '$arg'! It should be the format of 'NAME=VALUE'!\n";
			exit 1;
		}
	}
	foreach my $arg (sort keys %variables) {
		if ($variables{$arg} eq "" and !exists $changable_variables{$arg}) {
			print "Error: Option '$arg' is required!\n";
			exit 1;
		}
	}

	my $need_rerun = 0;
	my @inputs = @{$modules{$procedure}{inputs}};
	my @outputs = @{$modules{$procedure}{outputs}};
	my @requires = @{$modules{$procedure}{requires}};
	my $i;
	for ($i = 0; $i < scalar @inputs; ++$i) {
		while ($inputs[$i] =~ /\${(\w+)}/) {
			my $option_name = $1;
			$inputs[$i] =~ s/\${$option_name}/$variables{$option_name}/g;
		}
		if (!-e $inputs[$i]) {
			print "Error: Input file '$inputs[$i]' of procedure '$procedure' does not exist!\n";
			exit 1;
		}
	}
	for ($i = 0; $i < scalar @requires; ++$i) {
		while ($requires[$i] =~ /\${(\w+)}/) {
			my $option_name = $1;
			$requires[$i] =~ s/\${$option_name}/$variables{$option_name}/g;
		}
		if (!-e $requires[$i]) {
			print "Error: Input file '$requires[$i]' of procedure '$procedure' does not exist!\n";
			exit 1;
		}
	}
	if (scalar @outputs == 0) {
		$need_rerun = 1;
	} else {
		for ($i = 0; $i < scalar @outputs; ++$i) {
			while ($outputs[$i] =~ /\${(\w+)}/) {
				my $option_name = $1;
				$outputs[$i] =~ s/\${$option_name}/$variables{$option_name}/g;
			}
			if (-e $outputs[$i]) {
				foreach my $file (@inputs) {
					if ((stat($file))->mtime > (stat($outputs[$i]))->mtime) {
						$need_rerun = 1;
						last;
					}
				}
			} else {
				$need_rerun = 1;
				last;
			}
			last if ($need_rerun);
		}
	}

	if ($test_mode) {
		foreach my $command (@{$modules{$procedure}{commands}}) {
			while ($command =~ /\${(\w+)}/) {
				my $option_name = $1;
				$command =~ s/\${$option_name}/$variables{$option_name}/g;
			}

			if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
				if ($verbose) {
					print "#$command\n";
				}
				if (eval "$3") {
					$variables{$1} = $2;
				}
			} elsif ($command =~ /^SP_run\s+(\w+)/) {
				if ($verbose) {
					print "#$command\n";
				}
				if ($need_rerun) {
					my @procedure_options = parse_line($command);
					shift @procedure_options;
					my $procedure_name = shift @procedure_options;
					push @procedure_options, @{$argv_ref};
					run_procedure($procedure_name, \@procedure_options);
				}
			} else {
				print "#" unless ($need_rerun);
				print "$command\n";
			}
		}
		return 0;
	}

	return 0 unless $need_rerun;

	foreach my $command (@{$modules{$procedure}{commands}}) {
		while ($command =~ /\${(\w+)}/) {
			my $option_name = $1;
			$command =~ s/\${$option_name}/$variables{$option_name}/g;
		}

		if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
			if (eval "$3") {
				$variables{$1} = $2;
				print LOG_FILE "[SeqPipe] Option '$1' changes to '$2'.\n";
			}
			next;
		} elsif ($command =~ /^SP_run\s+(\w+)/) {
			my @procedure_options = parse_line($command);
			shift @procedure_options;
			my $procedure_name = shift @procedure_options;
			push @procedure_options, @{$argv_ref};
			run_procedure($procedure_name, \@procedure_options);
			next;
		}

		if ($modules{$procedure}{skip_record} eq "Y") {
			open BASH, "| /bin/bash " . ($procedure eq "sysinfo" ? ">>$seqpipe_log_dir/$$.sysinfo" : ">/dev/null") . " 2>/dev/null";
			print BASH "$command\n";
			close BASH;

			if ($? == -1) {
				print LOG_FILE "[SeqPipe] Command($$.$run_counter) starts failed!\n";
				close LOG_FILE;
				exit 1;
			} elsif ($? & 127) {
				print LOG_FILE "[SeqPipe] Command($$.$run_counter) starts failed! Child died with signal %d, %s coredump\n",
					($? & 127), ($? & 128) ? 'with' : 'without';
				close LOG_FILE;
				exit 1;
			} else {
				$return_value = ($? >> 8);
			}
		} else {
			$run_counter += 1;
			print LOG_FILE "[SeqPipe] Command($$.$run_counter): $command\n";

			my $start_time = time;
			my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($start_time);
			printf LOG_FILE "[SeqPipe] Command($$.$run_counter) starts at %04d-%02d-%02d %02d:%02d:%02d\n",
				$year + 1900, $mon + 1, $mday, $hour, $min, $sec;

			open FILE, ">>" . "$seqpipe_log_dir/$$.$run_counter.cmd";
			printf FILE "$command\n";
			close FILE;

			open BASH, "| /bin/bash >>$seqpipe_log_dir/$$.$run_counter.log 2>>$seqpipe_log_dir/$$.$run_counter.err"
				or die "Can not run bash for command: $command";
			print BASH $command;
			close BASH;

			if ($? == -1) {
				print LOG_FILE "[SeqPipe] Command($$.$run_counter) starts failed!\n";
				close LOG_FILE;
				exit 1;
			} elsif ($? & 127) {
				print LOG_FILE "[SeqPipe] Command($$.$run_counter) starts failed! Child died with signal %d, %s coredump\n",
					($? & 127), ($? & 128) ? 'with' : 'without';
				close LOG_FILE;
				exit 1;
			} else {
				$return_value = ($? >> 8);
			}

			my $end_time = time;
			my $elapsed_time = $end_time - $start_time;
			my $time_text = "";
			if ($elapsed_time >= 86400) {
				$time_text .= ($elapsed_time / 86400) . "d ";
				$elapsed_time %= 86400;
			}
			if ($time_text ne "" or $elapsed_time >= 3600) {
				$time_text .= ($elapsed_time / 3600) . "h ";
				$elapsed_time %= 3600;
			}
			if ($time_text ne "" or $elapsed_time >= 60) {
				$time_text .= ($elapsed_time / 3600) . "m ";
				$elapsed_time %= 60;
			}
			if ($time_text eq "" or $elapsed_time > 0) {
				$time_text .= $elapsed_time . "s ";
			}
			$time_text =~ s/\s$//g;
			($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($end_time);
			printf LOG_FILE "[SeqPipe] Command($$:$run_counter) ends at %04d-%02d-%02d %02d:%02d:%02d (elapsed: %s)\n",
				$year + 1900, $mon + 1, $mday, $hour, $min, $sec, $time_text;
		}
		
		if ($modules{$procedure}{ignore_retval} ne "Y") {
			if ($return_value != 0) {
				print LOG_FILE "[SeqPipe] Command($$:$run_counter) returns $return_value\n";
				last;
			}
		}
	}
	return $return_value;
}

my $procedure = "";

if ($#ARGV < 0) {
	$help_mode = 1;
} else {
	while (my $arg = shift @ARGV) {
		if ($arg eq '-h') {
			$help_mode = 1;
		} elsif ($arg eq '-H') {
			$help_mode = 1;
			$help_detail_mode = 1;
		} elsif ($arg eq '-v') {
			$verbose = 1;
		} elsif ($arg eq '-l') {
			$list_mode = 1;
		} elsif ($arg eq '-t') {
			$test_mode = 1;
		} elsif ($arg eq '-m') {
			if ($#ARGV < 0) {
				print "Error: missing argument for option '$arg'!\n";
				exit 1;
			}
			push(@module_files, shift @ARGV);
		} elsif ($arg =~ '^-') {
			print "Error: Unknown option '$arg'!\n";
			exit 1;
		} else {
			$procedure = $arg;
			last;
		}
	}
}
foreach my $arg (@ARGV) {
	if ($arg eq "-h") {
		$help_mode = 1;
		last;
	} elsif ($arg eq "-H") {
		$help_mode = 1;
		$help_detail_mode = 1;
		last;
	}
}
if ($procedure eq "") {
	$help_mode = 1;
}

foreach my $module_file (@module_files) {
	load_module $module_file;
}
if ($verbose) {
	printf "All %d files (%d modules) loaded.\n",
		scalar @module_files, scalar keys %modules;
}

if ($list_mode) {
	list_procedures;
	exit 1;
}
if ($help_mode and $procedure eq "") {
	print_usage;
	print "\n";
	exit 1;
}

if ($help_mode) {
	if (!exists $modules{$procedure}) {
		print "Error: Unknown procedure '$procedure'! Use '-l' option to list available procedures.\n";
		exit 1;
	}

	my %changable_variables;
	foreach my $command (@{$modules{$procedure}{commands}}) {
		if ($command =~ /^SP_set\s+(\w+)\s+\"(.*)\"\s+\"(.*)\"/) {
			$changable_variables{$1} = $2;
		}
	}

	print_usage;
	print "
Options for procedure '$procedure':
";
	for my $required (1,0) {
		foreach my $variable_name (sort keys %{$modules{$procedure}{variables}}) {
			my $default_value = "";
			if (${$modules{$procedure}{variables}}{$variable_name} ne "") {
				$default_value = ${$modules{$procedure}{variables}}{$variable_name};
			} elsif (exists $global_variables{$variable_name} and $global_variables{$variable_name} ne "") {
				$default_value = $global_variables{$variable_name};
			}

			if (($required and $default_value eq "" and !exists $changable_variables{$variable_name})
					or (!$required and ($default_value ne "" or exists $changable_variables{$variable_name}))) {
				printf "   %-30s %s\n", $variable_name,
					(($default_value eq "" and !exists $changable_variables{$variable_name})
					? "Required" : "Def: " . $default_value);
			}
		}
		if (!$help_detail_mode) { last; }
	}
	exit 1;
}

mkdir $seqpipe_log_dir, $default_dir_attr unless (-d $seqpipe_log_dir);

open LOG_FILE, ">>" . $seqpipe_log_dir . "/history.log";
printf LOG_FILE "%d\t%s\n", $$, $command_line;
close LOG_FILE;

my $start_time = time;
if (!$test_mode) {
	open LOG_FILE, "| tee -ai " . $seqpipe_log_dir . "/$$.log";

	printf LOG_FILE "[SeqPipe] Pipeline($$): $command_line\n";

	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($start_time);
	printf LOG_FILE "[SeqPipe] Pipeline($$) starts at %04d-%02d-%02d %02d:%02d:%02d\n",
		$year + 1900, $mon + 1, $mday, $hour, $min, $sec;

	if (!exists $modules{sysinfo}) {
		print "TIP: You may add a procedure named 'sysinfo' to record your current computational environment!";
	} else {
		run_procedure "sysinfo";
	}
}

run_procedure $procedure, \@ARGV;

if (!$test_mode) {
	my $end_time = time;
	my $elapsed_time = $end_time - $start_time;
	my $time_text = "";
	if ($elapsed_time >= 86400) {
		$time_text .= ($elapsed_time / 86400) . "d ";
		$elapsed_time %= 86400;
	}
	if ($time_text ne "" or $elapsed_time >= 3600) {
		$time_text .= ($elapsed_time / 3600) . "h ";
		$elapsed_time %= 3600;
	}
	if ($time_text ne "" or $elapsed_time >= 60) {
		$time_text .= ($elapsed_time / 3600) . "m ";
		$elapsed_time %= 60;
	}
	if ($time_text eq "" or $elapsed_time > 0) {
		$time_text .= $elapsed_time . "s ";
	}
	$time_text =~ s/\s$//g;
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($end_time);
	printf LOG_FILE "[SeqPipe] Pipeline($$) ends at %04d-%02d-%02d %02d:%02d:%02d (elapsed: %s)\n",
		$year + 1900, $mon + 1, $mday, $hour, $min, $sec, $time_text;

	close LOG_FILE;
}

exit $return_value;
