#!/bin/bash
#
#[seqpipe version="0.2.1 ($Id$)"]
#

###########################################################################
# This part defines global variables (options).

#[global]
TMP_DIR=/rd/tmp                         # Temporary directory
JAVA_MAX_MEM_SIZE=8G                    # For Java's -Xmx option
JAVA_GC_THREAD_NUM=4                    # For Java's -XX:ParallelGCThreads option

THREAD_NUM=1                            # For multiple-thread running

# Picard options
PICARD_ROOT=/rd/build/picard-tools       # Path of picard tools
MAX_RECORDS_IN_RAM=1875000               # For enhance performance of picard

# GATK options
GATK_ROOT=/rd/build/gatk                 # Path of GATK tools
GATK_KEY=${GATK_ROOT}/gatk_cbi.key       # Key file for offline using GATK
GATK_BUNDLE_ROOT=/rd/data/public/gatk_bundle/1.5/b37
DBSNP_VCF=${GATK_BUNDLE_ROOT}/dbsnp_135.b37.vcf
                                         # Path of dbSNP VCF file

FILTER_NAME="Filter"
FILTER_EXPRESSION="(AB ?: 0) > 0.75 || QUAL < 50.0 || DP < 10 || DP > 360 || (SB ?: -1) > -0.1 || MQ0>=4"
                                         # Filter expression for GATK
STAND_CALL_CONF=30                       # GATK UnifiedGenotyper -stand_call_conf
STAND_EMIT_CONF=10                       # GATK UnifiedGenotyper -stand_emit_conf

###########################################################################
# This part provide some SeqPipe primitives (SP_xxx), used only in run bash
#   scripts directly.

#[primitive]
# Usage:
#   SP_run <procedure> [NAME1=value1 ...]
function SP_run
{
	PROC_NAME=$1
	shift

	if [ -z "${PROC_NAME}" ]; then
		echo "Bad use of SP_run!" >/dev/stderr
		set -e
		exit 1
	fi

	if [ -z "$(type ${PROC_NAME} 2>/dev/null | grep 'function')" ]; then
		echo "Procedure '${PROC_NAME}' does not exist!" >/dev/stderr
		set -e
		exit 1
	fi

	( # Localize options to disable modifying options outside
		while [ $# -gt 0 ]; do
			if [ -z "$(echo $1 | egrep '^\w\w*=.*$')" ]; then
				echo "Bad option '$1' for procedure '${PROC_NAME}'!" >/dev/stderr
				set -e
				exit 1
			fi
			export $1
			shift
		done

		${PROC_NAME}
	)
}

#[primitive]
# Usage:
#   SP_set NAME=value [<checker> [NAME1=value1 ...]]
function SP_set
{
	SET_OPTION=$1
	shift

	if [ -z "${SET_OPTION}" ]; then
		echo "Bad use of SP_set!" >/dev/stderr
		set -e
		exit 1
	fi

	if [ $# -eq 0 ]; then
		export ${SET_OPTION}
	else
		SP_run $@ && export ${SET_OPTION}
	fi
}

#[primitive]
# Usage:
#   SP_eval NAME <evaluator> [NAME1=value1 ...]
function SP_eval
{
	OPTION_NAME=$1
	shift

	if [ -z "${OPTION_NAME}" -o $# -eq 0 ]; then
		echo "Bad use of SP_eval!" >/dev/stderr
		set -e
		exit 1
	fi

	export ${OPTION_NAME}=$(SP_run $@)
}

#[primitive]
function SP_parallel_begin
{
	# In running directly in bash, we do not support parallel mode
	:
}

#[primitive]
function SP_parallel_end
{
	# In running directly in bash, we do not support parallel mode
	:
}

###########################################################################

#[procedure type="sysinfo"]
function sysinfo
{
	echo    'System information:'
	echo -n '   System   : '; uname -a
	echo -n '   CPU      : '; lscpu | grep '^CPU(s):' | awk '{print $2}'
	echo -n '   Memory   : '; free -g | egrep 'Mem|Swap' | awk '{print $1$2"G"}' | paste - - | sed 's/\\t/ + /g'
	echo -n '   Date     : '; date '+%Y-%m-%d %H:%M:%S'
	echo -n '   Pwd      : '; pwd

	echo    'SeqPipe version:'
	echo -n '   Tools    : '; ${SEQPIPE_ROOT}/${SEQPIPE} | grep Version | cut -d' ' -f2-
	echo -n '   Pipeline : '; egrep '^#\[seqpipe version' ${SEQPIPE_ROOT}/default.pipe | cut -d'"' -f2

	echo    'Program versions:'
	echo -n '   bwa      : '; bwa |& grep Version | cut -d' ' -f2
	echo -n '   samtools : '; samtools |& grep Version | cut -d' ' -f2-
	echo -n '   bcftools : '; bcftools |& grep Version | cut -d' ' -f2-
	echo -n '   picard   : '; java -jar ${PICARD_ROOT}/ViewSam.jar -h |& grep Version | cut -d' ' -f2
	echo -n '   gatk     : '; java -jar ${GATK_ROOT}/GenomeAnalysisTK.jar --help | grep 'The Genome Analysis Toolkit' | cut -d',' -f1 | cut -d'v' -f2
	echo -n '   pindel   : '; pindel | grep 'Pindel version' | head -n1 | cut -d' ' -f3 | sed 's/,$//'
}

###########################################################################

#[procedure type="checker"]
function if_has_arg
{
	test -n "${ARG}"
}

#[procedure type="checker"]
function if_no_arg
{
	test -z "${ARG}"
}

#[procedure type="checker"]
#[procedure input="${INPUT_FASTA}"]
function if_fasta_is_long_genome
{
	# Here we assume a genome is long if its file is bigger than 100Mb
	test -n "$(ls -l ${INPUT_FASTA} | awk '$5>=1e8')"
}

#[procedure type="checker"]
#[procedure input="${INPUT_FASTQ}"]
function if_fastq_is_base_33
{
	# Pick up first ten reads's quality to see if it contains number.
	test -n "$(less ${INPUT_FASTQ} | sed -n '4~4p' | head -n1000 | grep '[0-9]')"
}

#[procedure type="checker"]
#[procedure input="${INPUT_FASTQ}"]
function if_fastq_is_not_base_33
{
	# Pick up first ten reads's quality to see if it contains number.
	test -z "$(less ${INPUT_FASTQ} | sed -n '4~4p' | head -n1000 | grep '[0-9]')"
}

###########################################################################

#[procedure type="stage"]
#[procedure input="${INPUT_FASTQ}" output="${OUTPUT_ZIP}"]
function fastqc_check
{
	fastqc --noextract --nogroup -o $(dirname ${OUTPUT_ZIP}) ${INPUT_FASTQ}
	mv $(dirname ${OUTPUT_ZIP})/$(basename ${INPUT_FASTQ} | sed 's/\(.fastq\|\)\(.gz\|.bz2\|\)$/_fastqc.zip/g') ${OUTPUT_ZIP}
}

#[procedure type="stage"]
#[procedure input="${REFERENCE}" output="${REFERENCE}.bwt"]
function bwa_build_index
{
	SP_set ALGORITHM="is"
	SP_set ALGORITHM="bwtsw" if_fasta_is_long_genome INPUT_FASTA="${REFERENCE}"

	bwa index -a ${ALGORITHM} ${REFERENCE}
}

#[procedure type="stage"]
#[procedure input="${FASTQ_1}" input="${FASTQ_2}" output="${OUTPUT_BAM}"]
#[procedure require="${REFERENCE}"]
function bwa_read_mapping
{
	SP_set BWA_ALN_OPTS="${BWA_ALN_OPTS}"
	SP_set BWA_ALN_OPTS="-I ${BWA_ALN_OPTS}" if_fastq_is_not_base_33 INPUT_FASTQ="${FASTQ_1}"
	SP_set BWA_SAMPE_OPTS="${BWA_SAMPE_OPTS}"
	SP_set BWA_END_IND="5"    # do not put an indel within INT bp towards the ends.
	SP_set BWA_GAP_EXT="-1"   # maximum number of gap extensions, -1 for disabling long gaps.

	# This will be skipped if the index files exist.
	SP_run bwa_build_index REFERENCE="${REFERENCE}"

	SP_parallel_begin
	
	#[command input="${FASTQ_1}" output="${FASTQ_1}.sai" require="${REFERENCE}"]
	bwa aln -t ${THREAD_NUM} -i ${BWA_END_IND} -e ${BWA_GAP_EXT} \
		${REFERENCE} ${FASTQ_1} -f ${FASTQ_1}.sai ${BWA_ALN_OPTS}
	
	#[command input="${FASTQ_2}" output="${FASTQ_2}.sai" require="${REFERENCE}"]
	bwa aln -t ${THREAD_NUM} -i ${BWA_END_IND} -e ${BWA_GAP_EXT} \
		${REFERENCE} ${FASTQ_2} -f ${FASTQ_2}.sai ${BWA_ALN_OPTS}
	
	SP_parallel_end

	#[command input="${FASTQ_1}" input="${FASTQ_1}.sai"]
	#[command input="${FASTQ_2}" input="${FASTQ_2}.sai"]
	#[command require="${REFERENCE}"]
	#[command output="${OUTPUT_BAM}"]
	bwa sampe -P ${REFERENCE} -a ${MAX_INSERT_SIZE} \
		${FASTQ_1}.sai ${FASTQ_2}.sai ${FASTQ_1} ${FASTQ_2} ${BWA_SAMPE_OPTS} \
		| samtools view -Sb - \
		> ${OUTPUT_BAM}

	#[command require="${OUTPUT_BAM}"]
	rm -f ${FASTQ_1}.sai ${FASTQ_2}.sai
}

#[procedure type="stage"]
#[procedure input="${FASTQ_1}.bz2" input="${FASTQ_2}.bz2" output="${OUTPUT_BAM}"]
#[procedure require="${REFERENCE}"]
function bwa_read_mapping_bz2
{
	SP_set BWA_ALN_OPTS="${BWA_ALN_OPTS}"
	SP_set BWA_ALN_OPTS="-I ${BWA_ALN_OPTS}" if_fastq_is_not_base_33 INPUT_FASTQ="${FASTQ_1}.bz2"
	SP_set BWA_SAMPE_OPTS="${BWA_SAMPE_OPTS}"
	SP_set BWA_END_IND="5"    # do not put an indel within INT bp towards the ends.
	SP_set BWA_GAP_EXT="-1"   # maximum number of gap extensions, -1 for disabling long gaps.

	# This will be skipped if the index files exist.
	SP_run bwa_build_index REFERENCE="${REFERENCE}"

	SP_parallel_begin
	
	#[command input="${FASTQ_1}.bz2" output="${FASTQ_1}.bz2.sai" require="${REFERENCE}"]
	bwa aln -t ${THREAD_NUM} -i ${BWA_END_IND} -e ${BWA_GAP_EXT} \
		${REFERENCE} <(bzcat ${FASTQ_1}.bz2) -f ${FASTQ_1}.bz2.sai ${BWA_ALN_OPTS}
	
	#[command input="${FASTQ_2}.bz2" output="${FASTQ_2}.bz2.sai" require="${REFERENCE}"]
	bwa aln -t ${THREAD_NUM} -i ${BWA_END_IND} -e ${BWA_GAP_EXT} \
		${REFERENCE} <(bzcat ${FASTQ_2}.bz2) -f ${FASTQ_2}.bz2.sai ${BWA_ALN_OPTS}
	
	SP_parallel_end

	#[command input="${FASTQ_1}.bz2" input="${FASTQ_1}.bz2.sai"]
	#[command input="${FASTQ_2}.bz2" input="${FASTQ_2}.bz2.sai"]
	#[command require="${REFERENCE}"]
	#[command output="${OUTPUT_BAM}"]
	bwa sampe -P ${REFERENCE} -a ${MAX_INSERT_SIZE} \
		${FASTQ_1}.bz2.sai ${FASTQ_2}.bz2.sai \
		<(bzcat ${FASTQ_1}.bz2) <(bzcat ${FASTQ_2}.bz2) ${BWA_SAMPE_OPTS} \
		| samtools view -Sb - \
		> ${OUTPUT_BAM}

	#[command require="${OUTPUT_BAM}"]
	rm -f ${FASTQ_1}.bz2.sai ${FASTQ_2}.bz2.sai
}

#[procedure type="stage"]
#[procedure input="${INPUT_FASTQ}" output="${OUTPUT_BAM}"]
#[procedure require="${REFERENCE}"]
function bwa_read_mapping_se
{
	SP_set BWA_ALN_OPTS="${BWA_ALN_OPTS}"
	SP_set BWA_ALN_OPTS="-I ${BWA_ALN_OPTS}" if_fastq_is_not_base_33 INPUT_FASTQ="${INPUT_FASTQ}"
	SP_set BWA_SAMSE_OPTS="${BWA_SAMSE_OPTS}"
	SP_set BWA_END_IND="5"    # do not put an indel within INT bp towards the ends.
	SP_set BWA_GAP_EXT="-1"   # maximum number of gap extensions, -1 for disabling long gaps.

	# This will be skipped if the index files exist.
	SP_run bwa_build_index REFERENCE="${REFERENCE}"

	#[command input="${INPUT_FASTQ}" output="${INPUT_FASTQ}.sai"]
	#[command require="${REFERENCE}"]
	bwa aln -t ${THREAD_NUM} -i ${BWA_END_IND} -e ${BWA_GAP_EXT} \
		${REFERENCE} ${INPUT_FASTQ} -f ${INPUT_FASTQ}.sai ${BWA_ALN_OPTS}

	#[command input="${INPUT_FASTQ}" input="${INPUT_FASTQ}.sai"]
	#[command require="${REFERENCE}"]
	#[command output="${OUTPUT_BAM}"]
	bwa samse ${REFERENCE} ${INPUT_FASTQ}.sai ${INPUT_FASTQ} ${BWA_SAMSE_OPTS} \
		| samtools view -Sb - \
		> ${OUTPUT_BAM}

	#[command require="${OUTPUT_BAM}"]
	rm -f ${INPUT_FASTQ}.sai
}

#[procedure type="stage"]
#[procedure input="${BAM_1}" input="${BAM_2}" output="${OUTPUT_BAM}"]
function merge_bam
{
	SP_set VALIDATION_STRINGENCY="STRICT" if_no_arg ARG="${VALIDATION_STRINGENCY}"
	SP_set BAM_3="${BAM_3}"
	SP_set BAM_4="${BAM_4}"
	SP_set BAM_5="${BAM_5}"
	SP_set BAM_6="${BAM_6}"
	SP_set BAM_7="${BAM_7}"
	SP_set BAM_8="${BAM_8}"
	SP_set BAM_9="${BAM_9}"
	SP_set MORE_INPUT_FILES=""
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_3}" if_has_arg ARG="${BAM_3}"
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_4}" if_has_arg ARG="${BAM_4}"
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_5}" if_has_arg ARG="${BAM_5}"
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_6}" if_has_arg ARG="${BAM_6}"
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_7}" if_has_arg ARG="${BAM_7}"
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_8}" if_has_arg ARG="${BAM_8}"
	SP_set MORE_INPUT_FILES="${MORE_INPUT_FILES} INPUT=${BAM_9}" if_has_arg ARG="${BAM_9}"

	#[command input="${BAM_1}" input="${BAM_2}" output="${OUTPUT_BAM}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-jar ${PICARD_ROOT}/MergeSamFiles.jar \
		MAX_RECORDS_IN_RAM=${MAX_RECORDS_IN_RAM} \
		TMP_DIR=${TMP_DIR} \
		VALIDATION_STRINGENCY=${VALIDATION_STRINGENCY} \
		COMPRESSION_LEVEL=9 \
		CREATE_INDEX=false \
		CREATE_MD5_FILE=false \
		INPUT=${BAM_1} \
		INPUT=${BAM_2} \
		${MORE_INPUT_FILES} \
		OUTPUT=${OUTPUT_BAM}

	#[command input="${OUTPUT_BAM}" output="${OUTPUT_BAM}.bai"]
	samtools index ${OUTPUT_BAM}
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
function select_reads
{
	#[command input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
	samtools view ${INPUT_BAM} -f ${SAM_FLAG} -b > ${OUTPUT_BAM}
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
function filter_reads
{
	#[command input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
	samtools view ${INPUT_BAM} -F ${SAM_FLAG} -b > ${OUTPUT_BAM}
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${MAPPED_BAM}" output="${UNMAPPED_BAM}"]
function select_mapped_reads
{
	SP_parallel_begin

	#[command input="${INPUT_BAM}" output="${MAPPED_BAM}"]
	SP_run filter_reads SAM_FLAG=4 INPUT_BAM=${INPUT_BAM} OUTPUT_BAM=${MAPPED_BAM}

	#[command input="${INPUT_BAM}" output="${UNMAPPED_BAM}"]
	SP_run select_reads SAM_FLAG=4 INPUT_BAM=${INPUT_BAM} OUTPUT_BAM=${UNMAPPED_BAM}

	SP_parallel_end
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
function sort_bam
{
	SP_set VALIDATION_STRINGENCY="STRICT" if_no_arg ARG="${VALIDATION_STRINGENCY}"

	#[command input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-jar ${PICARD_ROOT}/SortSam.jar \
		MAX_RECORDS_IN_RAM=${MAX_RECORDS_IN_RAM} \
		TMP_DIR=${TMP_DIR} \
		VALIDATION_STRINGENCY=${VALIDATION_STRINGENCY} \
		COMPRESSION_LEVEL=9 \
		CREATE_INDEX=false \
		CREATE_MD5_FILE=false \
		SORT_ORDER=coordinate \
		INPUT=${INPUT_BAM} \
		OUTPUT=${OUTPUT_BAM}

	#[command input="${OUTPUT_BAM}" output="${OUTPUT_BAM}.bai"]
	samtools index ${OUTPUT_BAM}
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${OUTPUT_FLAGSTAT_BZ2}"]
function flagstat_bam
{
	#[command input="${INPUT_BAM}" output="${OUTPUT_FLAGSTAT_BZ2}"]
	samtools flagstat ${INPUT_BAM} | bzip2 -9c > ${OUTPUT_FLAGSTAT_BZ2}
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${UNIQ_BAM}" output="${REST_BAM}"]
function select_unique_hit_reads
{
	#[command input="${INPUT_BAM}" output="${UNIQ_BAM}" output="${REST_BAM}"]
	samtools view -h ${INPUT_BAM} | tee \
		>(egrep '^@|XT:A:U' | samtools view -Sb - > ${UNIQ_BAM}) \
		>(egrep -v 'XT:A:U' | samtools view -Sb - > ${REST_BAM})
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
function mark_duplicate_reads
{
	SP_set VALIDATION_STRINGENCY="STRICT" if_no_arg ARG="${VALIDATION_STRINGENCY}"

	#[command input="${INPUT_BAM}" output="${OUTPUT_BAM}" output="${OUTPUT_BAM}.metrics"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-jar ${PICARD_ROOT}/MarkDuplicates.jar \
		MAX_RECORDS_IN_RAM=${MAX_RECORDS_IN_RAM} \
		TMP_DIR=${TMP_DIR} \
		VALIDATION_STRINGENCY=${VALIDATION_STRINGENCY} \
		COMPRESSION_LEVEL=9 \
		CREATE_INDEX=false \
		CREATE_MD5_FILE=false \
		INPUT=${INPUT_BAM} \
		OUTPUT=${OUTPUT_BAM} \
		METRICS_FILE=${OUTPUT_BAM}.metrics \
		REMOVE_DUPLICATES=false

	#[command input="${OUTPUT_BAM}" output="${OUTPUT_BAM}.bai"]
	samtools index ${OUTPUT_BAM}
}

#[procedure type="stage"]
#[procedure input="${SORTED_BAM}" output="${OUTPUT_MPILEUP_BZ2}"]
function samtools_mpileup
{
	SP_set REFERENCE="${REFERENCE}"
	SP_set SAMTOOLS_OPTS="${SAMTOOLS_OPTS}"
	SP_set SAMTOOLS_OPTS="${SAMTOOLS_OPTS} -f ${REFERENCE}" if_has_arg ARG="${REFERENCE}"

	#[command input="${SORTED_BAM}" output="${OUTPUT_MPILEUP_BZ2}"]
	samtools mpileup ${SAMTOOLS_OPTS} ${SORTED_BAM} | bzip2 -9c > ${OUTPUT_MPILEUP_BZ2}
}

#[procedure type="stage"]
#[procedure input="${SORTED_BAM}" output="${OUTPUT_BCF}"]
#[procedure require="${REFERENCE}"]
function samtools_call_variants
{
	#[command input="${SORTED_BAM}" output="${OUTPUT_BCF}"]
	samtools mpileup -f ${REFERENCE} ${SORTED_BAM} -u \
		| bcftools view -bvcg - \
		> ${OUTPUT_BCF}
}

#[procedure type="stage"]
function picard_add_or_replace_read_group
{
	# READ_GROUP_ID   : Read Group ID  Default value: 1. This option can be set to 'null' to clear the default 
	# LIBRARY         : Read Group Library  Required. 
	# PLATFORM        : Read Group platform (e.g. illumina, solid)  Required. 
	# PLATFORM_UNIT   : Read Group platform unit (eg. run barcode)  Required. 
	# SAMPLE_NAME     : Read Group sample name  Required. 
	# SEQ_CENTER_NAME : Read Group sequencing center name  Default value: null. 
	# DESCRIPTION     : Read Group description  Default value: null. 

	SP_set READ_GROUP_ID="1" if_no_arg ARG="${READ_GROUP_ID}"
	SP_set PLATFORM="illumina" if_no_arg ARG="${PLATFORM}"
	SP_set PLATFORM_UNIT="flowcell.lane" if_no_arg ARG="${PLATFORM_UNIT}"
	SP_set SEQ_CENTER_NAME="BGI" if_no_arg ARG="${SEQ_CENTER_NAME}"
	SP_set DESCRIPTION="${DESCRIPTION}"
	SP_set PICARD_OPTS="${PICARD_OPTS}"
	SP_set PICARD_OPTS="${PICARD_OPTS} RGDS=\"${DESCRIPTION}\"" if_has_arg ARG="${DESCRIPTION}"
	SP_set VALIDATION_STRINGENCY="STRICT" if_no_arg ARG="${VALIDATION_STRINGENCY}"

	#[command input="${INPUT_BAM}" output="${OUTPUT_BAM}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-jar ${PICARD_ROOT}/AddOrReplaceReadGroups.jar \
		MAX_RECORDS_IN_RAM=${MAX_RECORDS_IN_RAM} \
		TMP_DIR=${TMP_DIR} \
		VALIDATION_STRINGENCY=${VALIDATION_STRINGENCY} \
		COMPRESSION_LEVEL=9 \
		CREATE_INDEX=false \
		CREATE_MD5_FILE=false \
		INPUT=${INPUT_BAM} \
		OUTPUT=${OUTPUT_BAM} \
		RGID=${READ_GROUP_ID} \
		RGLB=${LIBRARY} \
		RGPL=${PLATFORM} \
		RGPU=${PLATFORM_UNIT} \
		RGSM=${SAMPLE_NAME} \
		RGCN=${SEQ_CENTER_NAME} \
		${PICARD_OPTS}

	#[command input="${OUTPUT_BAM}" output="${OUTPUT_BAM}.bai"]
	samtools index ${OUTPUT_BAM}
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${INPUT_BAM}.realign.fixmate"]
#[procedure require="${REFERENCE}" require="${DBSNP_VCF}"]
function gatk_indel_realign
{
	#[command input="${INPUT_BAM}" output="${INPUT_BAM}.intervals"]
	#[command require="${REFERENCE}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T RealignerTargetCreator \
		-R ${REFERENCE} \
		-I ${INPUT_BAM} \
		-o ${INPUT_BAM}.intervals \
		-known ${DBSNP_VCF} \
		--num_threads ${THREAD_NUM}

	#[command input="${INPUT_BAM}" input="$INPUT_BAM}.intervals"]
	#[command output="${INPUT_BAM}.realign"]
	#[command require="${REFERENCE}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T IndelRealigner \
		-R ${REFERENCE} \
		-I ${INPUT_BAM} \
		-targetIntervals ${INPUT_BAM}.intervals \
		-o ${INPUT_BAM}.realign

	#[command require="${INPUT_BAM}.realign"]
	rm -f ${INPUT_BAM}.intervals
	
	SP_set VALIDATION_STRINGENCY="STRICT" if_no_arg ARG="${VALIDATION_STRINGENCY}"

	#[command input="${INPUT_BAM}.realign" output="${INPUT_BAM}.realign.fixmate"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-jar ${PICARD_ROOT}/FixMateInformation.jar \
		MAX_RECORDS_IN_RAM=${MAX_RECORDS_IN_RAM} \
		TMP_DIR=${TMP_DIR} \
		VALIDATION_STRINGENCY=${VALIDATION_STRINGENCY} \
		COMPRESSION_LEVEL=9 \
		CREATE_INDEX=false \
		CREATE_MD5_FILE=false \
		INPUT=${INPUT_BAM}.realign \
		OUTPUT=${INPUT_BAM}.realign.fixmate

	#[command input="${INPUT_BAM}.realign.fixmate"]
	#[command output="${INPUT_BAM}.realign.fixmate.bai"]
	samtools index ${INPUT_BAM}.realign.fixmate

	#[command require="${INPUT_BAM}.realign.fixmate"]
	rm -f ${INPUT_BAM}.realign
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${INPUT_BAM}.recalibrated"]
#[procedure require="${REFERENCE}" require="${DBSNP_VCF}"]
function gatk_recalibrate
{
	#[command input="${INPUT_BAM}" output="${INPUT_BAM}.recalFile"]
	#[command require="${REFERENCE}" require="${DBSNP_VCF}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T CountCovariates \
		-R ${REFERENCE} \
		-I ${INPUT_BAM} \
		-knownSites ${DBSNP_VCF} \
		-cov ReadGroupCovariate \
		-cov QualityScoreCovariate \
		-cov CycleCovariate \
		-cov DinucCovariate \
		-recalFile ${INPUT_BAM}.recalFile \
		--num_threads ${THREAD_NUM}
	
	#[command input="${INPUT_BAM}" input="${INPUT_BAM}.recalFile"]
	#[command output="${INPUT_BAM}.recalbrated"]
	#[command require="${REFERENCE}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T TableRecalibration \
		-R ${REFERENCE} \
		-I ${INPUT_BAM} \
		-recalFile ${INPUT_BAM}.recalFile \
		-o ${INPUT_BAM}.recalibrated

	#[command require="${INPUT_BAM}.recalibrated"]
	rm -f ${INPUT_BAM}.recalFile
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${OUTPUT_VCF}"]
#[procedure require="${REFERENCE}" require="${DBSNP_VCF}"]
function gatk_genotype
{
	#[command input="${INPUT_BAM}" output="${OUTPUT_VCF}"]
	#[command require="${REFERENCE}" require="${DBSNP_VCF}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T UnifiedGenotyper \
		-R ${REFERENCE} \
		-I ${INPUT_BAM} \
		-glm BOTH \
		--min_base_quality_score 20 \
		--dbsnp ${DBSNP_VCF} \
		-stand_call_conf ${STAND_CALL_CONF} \
		-stand_emit_conf ${STAND_EMIT_CONF} \
		-o ${OUTPUT_VCF} \
		--num_threads ${THREAD_NUM}
}

#[procedure type="stage"]
#[procedure input="${INPUT_VCF}"]
#[procedure output="${INPUT_VCF}.indel"]
#[procedure output="${INPUT_VCF}.snp.filtered"]
#[procedure require="${REFERENCE}" require="${DBSNP_VCF}"]
function gatk_filter_variants
{
	#[command input="${INPUT_VCF}" output="${INPUT_VCF}.snp"]
	#[command require="${REFERENCE}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T SelectVariants \
		-R ${REFERENCE} \
		--variant ${INPUT_VCF} \
		-selectType SNP -selectType MNP \
		-o ${INPUT_VCF}.snp

	#[command input="${INPUT_VCF}" output="${INPUT_VCF}.indel"]
	#[command require="${REFERENCE}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T SelectVariants \
		-R ${REFERENCE} \
		--variant ${INPUT_VCF} \
		-selectType INDEL \
		-o ${INPUT_VCF}.indel

	#[command input="${INPUT_VCF}.snp" output="${INPUT_VCF}.snp.filtered"]
	#[command require="${REFERENCE}"]
	java -Xmx${JAVA_MAX_MEM_SIZE} -XX:ParallelGCThreads=${JAVA_GC_THREAD_NUM} \
		-Djava.io.tmpdir=${TMP_DIR} \
		-jar ${GATK_ROOT}/GenomeAnalysisTK.jar -et NO_ET -K ${GATK_KEY} \
		-T VariantFiltration \
		-R ${REFERENCE} \
		--variant ${INPUT_VCF}.snp \
		--filterExpression "${FILTER_EXPRESSION}" \
		--filterName "${FILTER_NAME}" \
		--clusterWindowSize 10 \
		-o ${INPUT_VCF}.snp.filtered
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}" output="${INPUT_BAM}.vcf.snp.filtered" output="${INPUT_BAM}.vcf.indel"]
function gatk_call_variants
{
	SP_set REFERENCE="${REFERENCE}"
	SP_set DBSNP_VCF="${DBSNP_VCF}"

	SP_run gatk_indel_realign \
		INPUT_BAM="${INPUT_BAM}"

	SP_run gatk_recalibrate \
		INPUT_BAM="${INPUT_BAM}.realign.fixmate"

	SP_run gatk_genotype \
		INPUT_BAM="${INPUT_BAM}.realign.fixmate.recalibrated" \
		OUTPUT_VCF="${INPUT_BAM}.vcf"

	SP_run gatk_filter_variants \
		INPUT_VCF="${INPUT_BAM}.vcf"
}

#[procedure type="evaluator"]
function eval_reference_name
{
	echo ${REFERENCE} | sed 's/\.\(fa\|fasta\)$//g'
}

#[procedure type="evaluator"]
function eval_reference_date
{
	stat ${REFERENCE} | grep Modify | awk '{print $2}' | sed 's/-//g'
}

#[procedure type="stage"]
#[procedure input="${INPUT_BAM}"]
#[procedure output="${OUTPUT_PREFIX}_D.vcf"]
#[procedure output="${OUTPUT_PREFIX}_SI.vcf"]
#[procedure output="${OUTPUT_PREFIX}_INV.vcf"]
#[procedure output="${OUTPUT_PREFIX}_TD.vcf"]
function pindel_call_structure_variants
{
	SP_eval REFERENCE_NAME eval_reference_name REFERENCE=${REFERENCE}
	SP_eval REFERENCE_DATE eval_reference_date REFERENCE=${REFERENCE}

	pindel -f ${REFERENCE} \
		-i <(echo "${INPUT_BAM} ${INSERT_SIZE} ${SAMPLE_NAME}") \
		-l -k -s -c ALL -o ${OUTPUT_PREFIX}

	pindel2vcf -r ${REFERENCE} -R ${REFERENCE_NAME} -d ${REFERENCE_DATE} \
		-p ${OUTPUT_PREFIX}_D -v ${OUTPUT_PREFIX}_D.vcf
	pindel2vcf -r ${REFERENCE} -R ${REFERENCE_NAME} -d ${REFERENCE_DATE} \
		-p ${OUTPUT_PREFIX}_SI -v ${OUTPUT_PREFIX}_SI.vcf
	pindel2vcf -r ${REFERENCE} -R ${REFERENCE_NAME} -d ${REFERENCE_DATE} \
		-p ${OUTPUT_PREFIX}_INV -v ${OUTPUT_PREFIX}_INV.vcf
	pindel2vcf -r ${REFERENCE} -R ${REFERENCE_NAME} -d ${REFERENCE_DATE} \
		-p ${OUTPUT_PREFIX}_TD -v ${OUTPUT_PREFIX}_TD.vcf
}

#[procedure type="stage"]
#[procedure input="${SAMPLE_NAME}.bam"]
#[procedure output="${SAMPLE_NAME}.bcf"]
function DNAseq_samtools_call_variants
{
	SP_run select_mapped_reads \
		INPUT_BAM="${SAMPLE_NAME}.bam" \
		MAPPED_BAM="${SAMPLE_NAME}.mapped.bam" \
		UNMAPPED_BAM="${SAMPLE_NAME}.unmapped.bam"

	SP_run select_unique_hit_reads \
		INPUT_BAM="${SAMPLE_NAME}.mapped.bam" \
		UNIQ_BAM="${SAMPLE_NAME}.mapped.uniq.bam" \
		REST_BAM="${SAMPLE_NAME}.mapped.non_uniq.bam"
	#[command require="${SAMPLE_NAME}.mapped.uniq.bam"]
	#[command require="${SAMPLE_NAME}.mapped.non_uniq.bam"]
	rm -f ${SAMPLE_NAME}.mapped.bam

	SP_run sort_bam \
		INPUT_BAM="${SAMPLE_NAME}.mapped.uniq.bam" \
		OUTPUT_BAM="${SAMPLE_NAME}.mapped.uniq.sorted.bam"
	#[command require="${SAMPLE_NAME}.mapped.uniq.sorted.bam"]
	rm -f ${SAMPLE_NAME}.mapped.uniq.bam

	SP_run mark_duplicate_reads \
		INPUT_BAM="${SAMPLE_NAME}.mapped.uniq.sorted.bam" \
		OUTPUT_BAM="${SAMPLE_NAME}.mapped.uniq.sorted.mkdup.bam"
	#[command require="${SAMPLE_NAME}.mapped.uniq.sorted.mkdup.bam"]
	rm -f ${SAMPLE_NAME}.mapped.uniq.sorted.bam \
		${SAMPLE_NAME}.mapped.uniq.sorted.bam.bai

	SP_run samtools_call_variants \
		REFERENCE="${REFERENCE}" \
		SORTED_BAM="${SAMPLE_NAME}.mapped.uniq.sorted.mkdup.bam" \
		OUTPUT_BCF="${SAMPLE_NAME}.bcf"
}

#[procedure type="stage"]
#[procedure input="${SAMPLE_NAME}.bam"]
#[procedure output="${SAMPLE_NAME}_sv_D.vcf"]
#[procedure output="${SAMPLE_NAME}_sv_SI.vcf"]
#[procedure output="${SAMPLE_NAME}_sv_INV.vcf"]
#[procedure output="${SAMPLE_NAME}_sv_TD.vcf"]
#[procedure require="${REFERENCE}"]
function DNAseq_pindel_call_structure_variants
{
	SP_run sort_bam \
		VALIDATION_STRINGENCY=SILENT \
		INPUT_BAM="${SAMPLE_NAME}.bam" \
		OUTPUT_BAM="${SAMPLE_NAME}.sorted.bam"

	SP_run pindel_call_structure_variants \
		REFERENCE="${REFERENCE}" \
		SAMPLE_NAME="${SAMPLE_NAME}" \
		INPUT_BAM="${SAMPLE_NAME}.sorted.bam" \
		INSERT_SIZE="${INSERT_SIZE}" \
		OUTPUT_PREFIX="${SAMPLE_NAME}_sv"
}

#[procedure type="pipeline"]
#[procedure input="${FASTQ_1}" input="${FASTQ_2}"]
#[procedure output="${SAMPLE_NAME}.bcf"]
#[procedure output="${SAMPLE_NAME}_sv_D.vcf"]
#[procedure output="${SAMPLE_NAME}_sv_SI.vcf"]
#[procedure output="${SAMPLE_NAME}_sv_INV.vcf"]
#[procedure output="${SAMPLE_NAME}_sv_TD.vcf"]
#[procedure require="${REFERENCE}"]
function DNAseq_analysis
{
	SP_run bwa_read_mapping \
		REFERENCE="${REFERENCE}" \
		FASTQ_1="${FASTQ_1}" FASTQ_2="${FASTQ_2}" \
		MAX_INSERT_SIZE="${MAX_INSERT_SIZE}" \
		OUTPUT_BAM="${SAMPLE_NAME}.bam"

	SP_parallel_begin

	SP_run DNAseq_samtools_call_variants \
		REFERENCE=${REFERENCE} \
		SAMPLE_NAME=${SAMPLE_NAME}

	SP_run DNAseq_pindel_call_structure_variants \
		REFERENCE=${REFERENCE} \
		SAMPLE_NAME=${SAMPLE_NAME} \
		INSERT_SIZE=${INSERT_SIZE}

	SP_parallel_end
}
